/** \file
 *  This OBJC source file was generated by $ANTLR version 3.3.1-SNAPSHOT Feb 24, 2011 11:25:29
 *
 *     -  From the grammar source file : /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g
 *     -                            On : 2011-02-24 11:32:43
 *     -                 for the lexer : GroupLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2010 Alan Condit
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// $ANTLR 3.3.1-SNAPSHOT Feb 24, 2011 11:25:29 /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g 2011-02-24 11:32:43


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "GroupLexer.h"
/* ----------------------------------------- */


/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */
#pragma mark Cyclic DFA implementation start DFA7
@implementation DFA7
const static NSInteger dfa7_eot[25] =
    {-1,4,-1,4,-1,-1,-1,-1,-1,-1,4,4,-1,-1,4,4,4,4,4,4,22,4,-1,24,-1};
const static NSInteger dfa7_eof[25] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1};
const static unichar dfa7_min[25] =
    {9,109,0,101,0,0,0,0,42,0,112,102,0,0,111,97,114,117,116,108,45,116,
     0,45,0};
const static unichar dfa7_max[25] =
    {123,109,0,101,0,0,0,0,47,0,112,102,0,0,111,97,114,117,116,108,122,116,
     0,122,0};
const static NSInteger dfa7_accept[25] =
    {-1,-1,2,-1,4,5,6,7,-1,10,-1,-1,8,9,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,3};
const static NSInteger dfa7_special[25] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1};
const static NSInteger dfa7_transition[] = {};
const static NSInteger dfa7_transition0[] = {18};
const static NSInteger dfa7_transition1[] = {20};
const static NSInteger dfa7_transition2[] = {14};
const static NSInteger dfa7_transition3[] = {16};
const static NSInteger dfa7_transition4[] = {15};
const static NSInteger dfa7_transition5[] = {4, -1, -1, 4, 4, 4, 4, 4, 4, 
 4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, -1, -1, 4, -1, 4, 
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
 4};
const static NSInteger dfa7_transition6[] = {23};
const static NSInteger dfa7_transition7[] = {21};
const static NSInteger dfa7_transition8[] = {12, -1, -1, -1, -1, 13};
const static NSInteger dfa7_transition9[] = {19};
const static NSInteger dfa7_transition10[] = {17};
const static NSInteger dfa7_transition11[] = {10};
const static NSInteger dfa7_transition12[] = {11};
const static NSInteger dfa7_transition13[] = {9, 9, -1, -1, 9, -1, -1, -1, 
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, 5, -1, 
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, 2, -1, 6, -1, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, -1, -1, 4, -1, 
 4, 4, 4, 3, 4, 4, 4, 4, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
 4, 4, 7};


+ (id) newDFA7WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
{
    return [[[DFA7 alloc] initWithRecognizer:aRecognizer] retain];
}

- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
{
    if ((self = [super initWithRecognizer:theRecognizer]) != nil) {
        decisionNumber = 7;
        eot = dfa7_eot;
        eof = dfa7_eof;
        min = dfa7_min;
        max = dfa7_max;
        accept = dfa7_accept;
        special = dfa7_special;
        if (!(transition = calloc(25, sizeof(void*)))) {
            [self release];
            return nil;
        }
        len = 25;
        transition[0] = dfa7_transition13;
        transition[1] = dfa7_transition11;
        transition[2] = dfa7_transition;
        transition[3] = dfa7_transition12;
        transition[4] = dfa7_transition;
        transition[5] = dfa7_transition;
        transition[6] = dfa7_transition;
        transition[7] = dfa7_transition;
        transition[8] = dfa7_transition8;
        transition[9] = dfa7_transition;
        transition[10] = dfa7_transition2;
        transition[11] = dfa7_transition4;
        transition[12] = dfa7_transition;
        transition[13] = dfa7_transition;
        transition[14] = dfa7_transition3;
        transition[15] = dfa7_transition10;
        transition[16] = dfa7_transition0;
        transition[17] = dfa7_transition9;
        transition[18] = dfa7_transition1;
        transition[19] = dfa7_transition7;
        transition[20] = dfa7_transition5;
        transition[21] = dfa7_transition6;
        transition[22] = dfa7_transition;
        transition[23] = dfa7_transition5;
        transition[24] = dfa7_transition;
    }
    return self;
}

- (void) dealloc
{
    free(transition);
    [super dealloc];
}

- (NSString *) description
{
    return @"1:1: Tokens : ( T__38 | T__39 | T__40 | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | COMMENT | LINE_COMMENT | WS );";
}


@end /* end DFA7 implementation */

#pragma mark Cyclic DFA implementation end DFA7



/** As per Terence: No returns for lexer rules! */
@implementation GroupLexer // line 330

+ (void) initialize
{
    [ANTLRBaseRecognizer setGrammarFileName:@"/Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g"];
}

+ (NSString *) tokenNameForType:(NSInteger)aTokenType
{
    return [[self getTokenNames] objectAtIndex:aTokenType];
}

+ (GroupLexer *)newGroupLexerWithCharStream:(id<ANTLRCharStream>)anInput
{
    return [[GroupLexer alloc] initWithCharStream:anInput];
}

- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
{
    if ((self = [super initWithCharStream:anInput State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:11+1]]) != nil) {

        dfa7 = [DFA7 newDFA7WithRecognizer:self];
    }
    return self;
}

- (void) dealloc
{
    [dfa7 release];
    [super dealloc];
}

/* ObjC Start of actions.lexer.methods */

@synthesize group;

- (void) reportError:(ANTLRRecognitionException *)e
{
    NSString *msg = nil;
    if ( [e isKindOfClass:[ANTLRNoViableAltException class]] ) {
#pragma error fix formatting
        msg = [NSString stringWithFormat:@"invalid character '***c'", [input LA:1]];
    }
    else if ( [e isKindOfClass:[ANTLRMismatchedTokenException class]] && ((ANTLRMismatchedTokenException *)e).expecting=='"' ) {
        msg = @"unterminated string";
    }
    else {
        msg = [self getErrorMessage:e TokenNames:[self getTokenNames]];
    }
    [group.errMgr groupSyntaxError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
}

- (NSString *) getSourceName
{
    return [super getSourceName];
}


/* ObjC end of actions.lexer.methods */
/* ObjC start methods() */
/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "T__38"
- (void) mT__38
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__38;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:48:7: ( 'import' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:48:9: 'import' // alt
        {
        [self matchString:@"import"]; 


        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__38" */

// $ANTLR start "T__39"
- (void) mT__39
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__39;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:49:7: ( '::=' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:49:9: '::=' // alt
        {
        [self matchString:@"::="]; 


        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__39" */

// $ANTLR start "T__40"
- (void) mT__40
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__40;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:50:7: ( 'default' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:50:9: 'default' // alt
        {
        [self matchString:@"default"]; 


        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__40" */

// $ANTLR start "ID"
- (void) mID
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = ID;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:282:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:282:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* // alt
        {
        if ((([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
            [input consume];

        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
            [self recover:mse];
            @throw mse;}

        do {
            NSInteger alt1=2;
            NSInteger LA1_0 = [input LA:1];
            if ( (LA1_0=='-'||(LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g: // alt
                    {
                    if ([input LA:1] == '-'||(([input LA:1] >= '0') && ([input LA:1] <= '9'))||(([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;

                default :
                    goto loop1;
            }
        } while (YES);
        loop1: ;


        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "ID" */

// $ANTLR start "STRING"
- (void) mSTRING
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = STRING;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:286:2: ( '\"' ( '\\\\' '\"' | '\\\\' ~ '\"' | '\\n' | ~ ( '\\\\' | '\"' | '\\n' ) )* '\"' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:286:4: '\"' ( '\\\\' '\"' | '\\\\' ~ '\"' | '\\n' | ~ ( '\\\\' | '\"' | '\\n' ) )* '\"' // alt
        {
        [self matchChar:'"']; 

        do {
            NSInteger alt2=5;
            NSInteger LA2_0 = [input LA:1];
            if ( (LA2_0=='\\') ) {
                NSInteger LA2_2 = [input LA:2];
                if ( (LA2_2=='"') ) {
                    alt2=1;
                }
                else if ( ((LA2_2>=0x0000 && LA2_2<='!')||(LA2_2>='#' && LA2_2<=0xFFFF)) ) {
                    alt2=2;
                }


            }
            else if ( (LA2_0=='\n') ) {
                alt2=3;
            }
            else if ( ((LA2_0>=0x0000 && LA2_0<='\t')||(LA2_0>=0x000B && LA2_0<='!')||(LA2_0>='#' && LA2_0<='[')||(LA2_0>=']' && LA2_0<=0xFFFF)) ) {
                alt2=4;
            }


            switch (alt2) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:287:5: '\\\\' '\"' // alt
                    {
                    [self matchChar:'\\']; 

                    [self matchChar:'"']; 


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:288:5: '\\\\' ~ '\"' // alt
                    {
                    [self matchChar:'\\']; 

                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '!'))||(([input LA:1] >= '#') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;
                case 3 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:289:5: '\\n' // alt
                    {

                    			NSString *msg = @"\\n in string";
                        		ANTLRNoViableAltException *e = [ANTLRNoViableAltException newANTLRNoViableAltException:0 state:0 stream:input];
                    			[group.errMgr groupLexerError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
                    			
                    [self matchChar:'\n']; 


                    }
                    break;
                case 4 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:295:5: ~ ( '\\\\' | '\"' | '\\n' ) // alt
                    {
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '\t'))||(([input LA:1] >= 0x000B) && ([input LA:1] <= '!'))||(([input LA:1] >= '#') && ([input LA:1] <= '['))||(([input LA:1] >= ']') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;

                default :
                    goto loop2;
            }
        } while (YES);
        loop2: ;

        [self matchChar:'"']; 


        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "STRING" */

// $ANTLR start "BIGSTRING"
- (void) mBIGSTRING
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = BIGSTRING;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:301:2: ( '<<' ( options {greedy=false; } : '\\\\' '>' | '\\\\' ~ '>' | ~ '\\\\' )* '>>' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:301:4: '<<' ( options {greedy=false; } : '\\\\' '>' | '\\\\' ~ '>' | ~ '\\\\' )* '>>' // alt
        {
        [self matchString:@"<<"]; 

        do {
            NSInteger alt3=4;
            NSInteger LA3_0 = [input LA:1];
            if ( (LA3_0=='>') ) {
                NSInteger LA3_1 = [input LA:2];
                if ( (LA3_1=='>') ) {
                    alt3=4;
                }
                else if ( ((LA3_1>=0x0000 && LA3_1<='=')||(LA3_1>='?' && LA3_1<=0xFFFF)) ) {
                    alt3=3;
                }


            }
            else if ( (LA3_0=='\\') ) {
                NSInteger LA3_2 = [input LA:2];
                if ( (LA3_2=='>') ) {
                    alt3=1;
                }
                else if ( ((LA3_2>=0x0000 && LA3_2<='=')||(LA3_2>='?' && LA3_2<=0xFFFF)) ) {
                    alt3=2;
                }


            }
            else if ( ((LA3_0>=0x0000 && LA3_0<='=')||(LA3_0>='?' && LA3_0<='[')||(LA3_0>=']' && LA3_0<=0xFFFF)) ) {
                alt3=3;
            }


            switch (alt3) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:303:5: '\\\\' '>' // alt
                    {
                    [self matchChar:'\\']; 

                    [self matchChar:'>']; 


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:304:5: '\\\\' ~ '>' // alt
                    {
                    [self matchChar:'\\']; 

                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '='))||(([input LA:1] >= '?') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;
                case 3 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:305:5: ~ '\\\\' // alt
                    {
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '['))||(([input LA:1] >= ']') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;

                default :
                    goto loop3;
            }
        } while (YES);
        loop3: ;

        [self matchString:@">>"]; 


                NSString *txt = [[self getText] stringByReplacingOccurrencesOfString:@"\\\\>" withString:@">"];
        		[self setText:txt];
        		

        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "BIGSTRING" */

// $ANTLR start "ANONYMOUS_TEMPLATE"
- (void) mANONYMOUS_TEMPLATE
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = ANONYMOUS_TEMPLATE;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:315:5: ( '{' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:315:7: '{' // alt
        {
        [self matchChar:'{']; 


        		ANTLRCommonToken *templateToken = [ANTLRCommonToken newANTLRCommonToken:input
                                                                                   Type:ANONYMOUS_TEMPLATE
                                                                                Channel:0
        		                                                                  Start:[input getIndex]
        		                                                                   Stop:[input getIndex]];
        		STLexer *lexer =
        			[STLexer newSTLexer:group.errMgr
        			              input:input
                          templateToken:templateToken
        			 delimiterStartChar:group.delimiterStartChar
        			  delimiterStopChar:group.delimiterStopChar];
        		[lexer setSubtemplateDepth:1];
        		ANTLRCommonToken *t = [lexer nextToken];
        		while ( [lexer subtemplateDepth] >= 1 || [t getType] != RCURLY ) {
        			if ( [t getType] == STLexer.EOF_TYPE ) {
                    	ANTLRMismatchedTokenException *e = [ANTLRMismatchedTokenException newANTLRMismatchedTokenException:'}' Stream:input];
        				NSString *msg = @"missing final '}' in {...} anonymous template";
            			[group.errMgr groupLexerError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
        				break;
        			}
        			t = [lexer nextToken];
        		}
        		

        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "ANONYMOUS_TEMPLATE" */

// $ANTLR start "COMMENT"
- (void) mCOMMENT
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = COMMENT;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:345:5: ( '/*' ( options {greedy=false; } : . )* '*/' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:345:9: '/*' ( options {greedy=false; } : . )* '*/' // alt
        {
        [self matchString:@"/*"]; 

        do {
            NSInteger alt4=2;
            NSInteger LA4_0 = [input LA:1];
            if ( (LA4_0=='*') ) {
                NSInteger LA4_1 = [input LA:2];
                if ( (LA4_1=='/') ) {
                    alt4=2;
                }
                else if ( ((LA4_1>=0x0000 && LA4_1<='.')||(LA4_1>='0' && LA4_1<=0xFFFF)) ) {
                    alt4=1;
                }


            }
            else if ( ((LA4_0>=0x0000 && LA4_0<=')')||(LA4_0>='+' && LA4_0<=0xFFFF)) ) {
                alt4=1;
            }


            switch (alt4) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:345:42: . // alt
                    {
                    [self matchAny]; 


                    }
                    break;

                default :
                    goto loop4;
            }
        } while (YES);
        loop4: ;

        [self matchString:@"*/"]; 

         [self skip]; 

        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "COMMENT" */

// $ANTLR start "LINE_COMMENT"
- (void) mLINE_COMMENT
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = LINE_COMMENT;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:349:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:349:7: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' // alt
        {
        [self matchString:@"//"]; 

        do {
            NSInteger alt5=2;
            NSInteger LA5_0 = [input LA:1];
            if ( ((LA5_0>=0x0000 && LA5_0<='\t')||(LA5_0>=0x000B && LA5_0<='\f')||(LA5_0>=0x000E && LA5_0<=0xFFFF)) ) {
                alt5=1;
            }


            switch (alt5) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:349:12: ~ ( '\\n' | '\\r' ) // alt
                    {
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '\t'))||(([input LA:1] >= 0x000B) && ([input LA:1] <= '\f'))||(([input LA:1] >= 0x000E) && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;

                default :
                    goto loop5;
            }
        } while (YES);
        loop5: ;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:349:26: ( '\\r' )? // block
        NSInteger alt6=2;
        NSInteger LA6_0 = [input LA:1];

        if ( (LA6_0=='\r') ) {
            alt6=1;
        }
        switch (alt6) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:349:26: '\\r' // alt
                {
                [self matchChar:'\r']; 


                }
                break;

        }

        [self matchChar:'\n']; 

         [self skip]; 

        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "LINE_COMMENT" */

// $ANTLR start "WS"
- (void) mWS
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = WS;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:352:5: ( ( ' ' | '\\r' | '\\t' | '\\n' ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:352:7: ( ' ' | '\\r' | '\\t' | '\\n' ) // alt
        {
        if ((([input LA:1] >= '\t') && ([input LA:1] <= '\n'))||[input LA:1] == '\r'||[input LA:1] == ' ') {
            [input consume];

        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
            [self recover:mse];
            @throw mse;}

         [self skip]; 

        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "WS" */

- (void) mTokens
{
    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:8: ( T__38 | T__39 | T__40 | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | COMMENT | LINE_COMMENT | WS ) //ruleblock
    NSInteger alt7=10;
    alt7 = [dfa7 predict:input];
    switch (alt7) {
        case 1 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:10: T__38 // alt
            {
            [self mT__38]; 


            }
            break;
        case 2 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:16: T__39 // alt
            {
            [self mT__39]; 


            }
            break;
        case 3 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:22: T__40 // alt
            {
            [self mT__40]; 


            }
            break;
        case 4 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:28: ID // alt
            {
            [self mID]; 


            }
            break;
        case 5 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:31: STRING // alt
            {
            [self mSTRING]; 


            }
            break;
        case 6 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:38: BIGSTRING // alt
            {
            [self mBIGSTRING]; 


            }
            break;
        case 7 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:48: ANONYMOUS_TEMPLATE // alt
            {
            [self mANONYMOUS_TEMPLATE]; 


            }
            break;
        case 8 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:67: COMMENT // alt
            {
            [self mCOMMENT]; 


            }
            break;
        case 9 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:75: LINE_COMMENT // alt
            {
            [self mLINE_COMMENT]; 


            }
            break;
        case 10 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:88: WS // alt
            {
            [self mWS]; 


            }
            break;

    }

}

@end /* end of GroupLexer implementation line 397 */