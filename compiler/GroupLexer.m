/** \file
 *  This OBJC source file was generated by $ANTLR version 3.3.1-SNAPSHOT Mar 09, 2011 24:00:43
 *
 *     -  From the grammar source file : /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g
 *     -                            On : 2011-04-06 18:27:39
 *     -                 for the lexer : GroupLexerLexer *
 * Editing it, at least manually, is not wise.
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2010 Alan Condit
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// $ANTLR 3.3.1-SNAPSHOT Mar 09, 2011 24:00:43 /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g 2011-04-06 18:27:39


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "GroupLexer.h"
/* ----------------------------------------- */


/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */
#pragma mark Cyclic DFA implementation start DFA8
@implementation DFA8
const static NSInteger dfa8_eot[63] =
    {-1,16,16,16,-1,16,27,-1,-1,-1,-1,-1,-1,-1,-1,16,-1,-1,-1,-1,-1,-1,16,
     16,16,16,-1,-1,16,-1,-1,-1,-1,16,16,16,16,16,44,16,16,16,16,16,-1,50,
     16,16,53,16,-1,55,16,-1,16,-1,16,59,16,-1,16,62,-1};
const static NSInteger dfa8_eof[63] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static unichar dfa8_min[63] =
    {9,114,97,109,0,114,58,0,0,0,0,0,0,0,0,101,0,0,37,0,42,0,117,108,112,
     111,0,0,102,0,0,0,0,101,115,108,117,97,45,101,114,101,112,117,0,45,
     116,109,45,108,0,45,101,0,116,0,110,45,116,0,115,45,0};
const static unichar dfa8_max[63] =
    {123,114,97,109,0,114,58,0,0,0,0,0,0,0,0,101,0,0,60,0,47,0,117,108,112,
     111,0,0,102,0,0,0,0,101,115,111,117,97,122,101,114,101,112,117,0,122,
     116,109,122,108,0,122,101,0,116,0,110,122,116,0,115,122,0};
const static NSInteger dfa8_accept[63] =
    {-1,-1,-1,-1,4,-1,-1,8,9,10,11,12,14,15,16,-1,18,19,-1,22,-1,25,-1,-1,
     -1,-1,13,6,-1,20,21,23,24,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,
     -1,-1,-1,2,-1,-1,5,-1,3,-1,-1,-1,17,-1,-1,7};
const static NSInteger dfa8_special[63] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa8_transition[] = {};
const static NSInteger dfa8_transition0[] = {47};
const static NSInteger dfa8_transition1[] = {52};
const static NSInteger dfa8_transition2[] = {29, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30};
const static NSInteger dfa8_transition3[] = {16, -1, -1, 16, 16, 16, 16, 
 16, 16, 16, 16, 16, 16, -1, -1, -1, -1, -1, -1, -1, 16, 16, 16, 16, 16, 
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
 16, 16, 16, -1, -1, -1, -1, 16, -1, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16};
const static NSInteger dfa8_transition4[] = {22};
const static NSInteger dfa8_transition5[] = {60};
const static NSInteger dfa8_transition6[] = {23};
const static NSInteger dfa8_transition7[] = {61};
const static NSInteger dfa8_transition8[] = {56};
const static NSInteger dfa8_transition9[] = {58};
const static NSInteger dfa8_transition10[] = {48};
const static NSInteger dfa8_transition11[] = {42};
const static NSInteger dfa8_transition12[] = {36};
const static NSInteger dfa8_transition13[] = {24};
const static NSInteger dfa8_transition14[] = {28};
const static NSInteger dfa8_transition15[] = {26};
const static NSInteger dfa8_transition16[] = {21, 21, -1, -1, 21, -1, -1, 
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, 
 17, -1, -1, -1, -1, -1, 10, 11, -1, -1, 7, -1, 4, 20, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, 6, 8, 18, 12, -1, -1, 9, 16, 16, 16, 16, 16, 16, 16, 
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
 16, 13, -1, 14, -1, 16, -1, 16, 16, 16, 15, 16, 2, 5, 16, 3, 16, 16, 16, 
 16, 16, 16, 16, 16, 16, 16, 1, 16, 16, 16, 16, 16, 16, 19};
const static NSInteger dfa8_transition17[] = {34};
const static NSInteger dfa8_transition18[] = {31, -1, -1, -1, -1, 32};
const static NSInteger dfa8_transition19[] = {39};
const static NSInteger dfa8_transition20[] = {43};
const static NSInteger dfa8_transition21[] = {45};
const static NSInteger dfa8_transition22[] = {49};
const static NSInteger dfa8_transition23[] = {54};
const static NSInteger dfa8_transition24[] = {57};
const static NSInteger dfa8_transition25[] = {37};
const static NSInteger dfa8_transition26[] = {46};
const static NSInteger dfa8_transition27[] = {51};
const static NSInteger dfa8_transition28[] = {41, -1, -1, 40};
const static NSInteger dfa8_transition29[] = {35};
const static NSInteger dfa8_transition30[] = {25};
const static NSInteger dfa8_transition31[] = {38};
const static NSInteger dfa8_transition32[] = {33};


+ (id) newDFA8WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
{
    return [[[DFA8 alloc] initWithRecognizer:aRecognizer] retain];
}

- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
{
    self=[super initWithRecognizer:theRecognizer];
    if ( self != nil ) {
        decisionNumber = 8;
        eot = dfa8_eot;
        eof = dfa8_eof;
        min = dfa8_min;
        max = dfa8_max;
        accept = dfa8_accept;
        special = dfa8_special;
        if (!(transition = calloc(63, sizeof(void*)))) {
            [self release];
            return nil;
        }
        len = 63;
        transition[0] = dfa8_transition16;
        transition[1] = dfa8_transition4;
        transition[2] = dfa8_transition6;
        transition[3] = dfa8_transition13;
        transition[4] = dfa8_transition;
        transition[5] = dfa8_transition30;
        transition[6] = dfa8_transition15;
        transition[7] = dfa8_transition;
        transition[8] = dfa8_transition;
        transition[9] = dfa8_transition;
        transition[10] = dfa8_transition;
        transition[11] = dfa8_transition;
        transition[12] = dfa8_transition;
        transition[13] = dfa8_transition;
        transition[14] = dfa8_transition;
        transition[15] = dfa8_transition14;
        transition[16] = dfa8_transition;
        transition[17] = dfa8_transition;
        transition[18] = dfa8_transition2;
        transition[19] = dfa8_transition;
        transition[20] = dfa8_transition18;
        transition[21] = dfa8_transition;
        transition[22] = dfa8_transition32;
        transition[23] = dfa8_transition17;
        transition[24] = dfa8_transition29;
        transition[25] = dfa8_transition12;
        transition[26] = dfa8_transition;
        transition[27] = dfa8_transition;
        transition[28] = dfa8_transition25;
        transition[29] = dfa8_transition;
        transition[30] = dfa8_transition;
        transition[31] = dfa8_transition;
        transition[32] = dfa8_transition;
        transition[33] = dfa8_transition31;
        transition[34] = dfa8_transition19;
        transition[35] = dfa8_transition28;
        transition[36] = dfa8_transition11;
        transition[37] = dfa8_transition20;
        transition[38] = dfa8_transition3;
        transition[39] = dfa8_transition21;
        transition[40] = dfa8_transition26;
        transition[41] = dfa8_transition0;
        transition[42] = dfa8_transition10;
        transition[43] = dfa8_transition22;
        transition[44] = dfa8_transition;
        transition[45] = dfa8_transition3;
        transition[46] = dfa8_transition27;
        transition[47] = dfa8_transition1;
        transition[48] = dfa8_transition3;
        transition[49] = dfa8_transition23;
        transition[50] = dfa8_transition;
        transition[51] = dfa8_transition3;
        transition[52] = dfa8_transition8;
        transition[53] = dfa8_transition;
        transition[54] = dfa8_transition24;
        transition[55] = dfa8_transition;
        transition[56] = dfa8_transition9;
        transition[57] = dfa8_transition3;
        transition[58] = dfa8_transition5;
        transition[59] = dfa8_transition;
        transition[60] = dfa8_transition7;
        transition[61] = dfa8_transition3;
        transition[62] = dfa8_transition;
    }
    return self;
}

- (void) dealloc
{
    free(transition);
    [super dealloc];
}

- (NSString *) description
{
    return @"1:1: Tokens : ( T_TRUE | T_FALSE | T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | ID | STRING | BIGSTRING_NO_NL | BIGSTRING | ANONYMOUS_TEMPLATE | COMMENT | LINE_COMMENT | WS );";
}


@end /* end DFA8 implementation */

#pragma mark Cyclic DFA implementation end DFA8



/** As per Terence: No returns for lexer rules! */
@implementation GroupLexer // line 330

+ (void) initialize
{
    [ANTLRBaseRecognizer setGrammarFileName:@"/Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g"];
}

+ (NSString *) tokenNameForType:(NSInteger)aTokenType
{
    return [[self getTokenNames] objectAtIndex:aTokenType];
}

+ (GroupLexer *)newGroupLexerWithCharStream:(id<ANTLRCharStream>)anInput
{
    return [[GroupLexer alloc] initWithCharStream:anInput];
}

- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
{
    self = [super initWithCharStream:anInput State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:26+1]];
    if ( self != nil ) {

        dfa8 = [DFA8 newDFA8WithRecognizer:self];
    }
    return self;
}

- (void) dealloc
{
    [dfa8 release];
    [super dealloc];
}

/* ObjC Start of actions.lexer.methods */

@synthesize group;

- (void) reportError:(ANTLRRecognitionException *)e
{
    NSString *msg = nil;
    if ( [e isKindOfClass:[ANTLRNoViableAltException class]] ) {
#pragma error fix formatting
        msg = [NSString stringWithFormat:@"invalid character '***c'", [input LA:1]];
    }
    else if ( [e isKindOfClass:[ANTLRMismatchedTokenException class]] && ((ANTLRMismatchedTokenException *)e).expecting=='"' ) {
        msg = @"unterminated string";
    }
    else {
        msg = [self getErrorMessage:e TokenNames:[self getTokenNames]];
    }
    [group.errMgr groupSyntaxError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
}

- (NSString *) getSourceName
{
    return [super getSourceName];
}


/* ObjC end of actions.lexer.methods */
/* ObjC start methods() */
/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "T_TRUE"
- (void) mT_TRUE
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T_TRUE;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:78:8: ( 'true' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:78:10: 'true' // alt
        {
        [self matchString:@"true"]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T_TRUE" */

// $ANTLR start "T_FALSE"
- (void) mT_FALSE
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T_FALSE;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:79:9: ( 'false' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:79:11: 'false' // alt
        {
        [self matchString:@"false"]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T_FALSE" */

// $ANTLR start "T__14"
- (void) mT__14
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__14;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:80:7: ( 'import' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:80:9: 'import' // alt
        {
        [self matchString:@"import"]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__14" */

// $ANTLR start "T__15"
- (void) mT__15
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__15;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:81:7: ( '.' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:81:9: '.' // alt
        {
        [self matchChar:'.']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__15" */

// $ANTLR start "T__16"
- (void) mT__16
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__16;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:82:7: ( 'group' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:82:9: 'group' // alt
        {
        [self matchString:@"group"]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__16" */

// $ANTLR start "T__17"
- (void) mT__17
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__17;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:83:7: ( ':' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:83:9: ':' // alt
        {
        [self matchChar:':']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__17" */

// $ANTLR start "T__18"
- (void) mT__18
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__18;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:84:7: ( 'implements' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:84:9: 'implements' // alt
        {
        [self matchString:@"implements"]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__18" */

// $ANTLR start "T__19"
- (void) mT__19
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__19;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:85:7: ( ',' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:85:9: ',' // alt
        {
        [self matchChar:',']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__19" */

// $ANTLR start "T__20"
- (void) mT__20
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__20;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:86:7: ( ';' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:86:9: ';' // alt
        {
        [self matchChar:';']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__20" */

// $ANTLR start "T__21"
- (void) mT__21
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__21;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:87:7: ( '@' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:87:9: '@' // alt
        {
        [self matchChar:'@']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__21" */

// $ANTLR start "T__22"
- (void) mT__22
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__22;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:88:7: ( '(' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:88:9: '(' // alt
        {
        [self matchChar:'(']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__22" */

// $ANTLR start "T__23"
- (void) mT__23
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__23;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:89:7: ( ')' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:89:9: ')' // alt
        {
        [self matchChar:')']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__23" */

// $ANTLR start "T__24"
- (void) mT__24
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__24;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:90:7: ( '::=' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:90:9: '::=' // alt
        {
        [self matchString:@"::="]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__24" */

// $ANTLR start "T__25"
- (void) mT__25
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__25;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:91:7: ( '=' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:91:9: '=' // alt
        {
        [self matchChar:'=']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__25" */

// $ANTLR start "T__26"
- (void) mT__26
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__26;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:92:7: ( '[' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:92:9: '[' // alt
        {
        [self matchChar:'[']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__26" */

// $ANTLR start "T__27"
- (void) mT__27
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__27;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:93:7: ( ']' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:93:9: ']' // alt
        {
        [self matchChar:']']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__27" */

// $ANTLR start "T__28"
- (void) mT__28
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__28;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:94:7: ( 'default' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:94:9: 'default' // alt
        {
        [self matchString:@"default"]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "T__28" */

// $ANTLR start "ID"
- (void) mID
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = ID;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:363:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:363:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* // alt
        {
        if ((([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
            [input consume];

        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
            [self recover:mse];
            @throw mse;}

        do {
            NSInteger alt1=2;
            NSInteger LA1_0 = [input LA:1];
            if ( (LA1_0=='-'||(LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g: // alt
                    {
                    if ([input LA:1] == '-'||(([input LA:1] >= '0') && ([input LA:1] <= '9'))||(([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;

                default :
                    goto loop1;
            }
        } while (YES);
        loop1: ;


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "ID" */

// $ANTLR start "STRING"
- (void) mSTRING
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = STRING;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:367:2: ( '\"' ( '\\\\' '\"' | '\\\\' ~ '\"' | '\\n' | ~ ( '\\\\' | '\"' | '\\n' ) )* '\"' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:367:4: '\"' ( '\\\\' '\"' | '\\\\' ~ '\"' | '\\n' | ~ ( '\\\\' | '\"' | '\\n' ) )* '\"' // alt
        {
        [self matchChar:'"']; 

        do {
            NSInteger alt2=5;
            NSInteger LA2_0 = [input LA:1];
            if ( (LA2_0=='\\') ) {
                NSInteger LA2_2 = [input LA:2];
                if ( (LA2_2=='"') ) {
                    alt2=1;
                }
                else if ( ((LA2_2>=0x0000 && LA2_2<='!')||(LA2_2>='#' && LA2_2<=0xFFFF)) ) {
                    alt2=2;
                }


            }
            else if ( (LA2_0=='\n') ) {
                alt2=3;
            }
            else if ( ((LA2_0>=0x0000 && LA2_0<='\t')||(LA2_0>=0x000B && LA2_0<='!')||(LA2_0>='#' && LA2_0<='[')||(LA2_0>=']' && LA2_0<=0xFFFF)) ) {
                alt2=4;
            }


            switch (alt2) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:368:5: '\\\\' '\"' // alt
                    {
                    [self matchChar:'\\']; 

                    [self matchChar:'"']; 


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:369:5: '\\\\' ~ '\"' // alt
                    {
                    [self matchChar:'\\']; 

                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '!'))||(([input LA:1] >= '#') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;
                case 3 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:370:5: '\\n' // alt
                    {

                    			NSString *msg = @"\\n in string";
                        		ANTLRNoViableAltException *e = [ANTLRNoViableAltException newException:0 state:0 stream:input];
                    			[group.errMgr groupLexerError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
                    			
                    [self matchChar:'\n']; 


                    }
                    break;
                case 4 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:376:5: ~ ( '\\\\' | '\"' | '\\n' ) // alt
                    {
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '\t'))||(([input LA:1] >= 0x000B) && ([input LA:1] <= '!'))||(([input LA:1] >= '#') && ([input LA:1] <= '['))||(([input LA:1] >= ']') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;

                default :
                    goto loop2;
            }
        } while (YES);
        loop2: ;

        [self matchChar:'"']; 


                NSString *txt = [[self getText]  stringByReplacingOccurrencesOfString:@"\\\\\"" withString:@"\""];
        		[self setText:txt];
        		

        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "STRING" */

// $ANTLR start "BIGSTRING_NO_NL"
- (void) mBIGSTRING_NO_NL
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T_BIGSTRING_NO_NL;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:386:2: ( '<%' ( options {greedy=false; } : . )* '%>' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:386:4: '<%' ( options {greedy=false; } : . )* '%>' // alt
        {
        [self matchString:@"<%"]; 

        do {
            NSInteger alt3=2;
            NSInteger LA3_0 = [input LA:1];
            if ( (LA3_0=='%') ) {
                NSInteger LA3_1 = [input LA:2];
                if ( (LA3_1=='>') ) {
                    alt3=2;
                }
                else if ( ((LA3_1>=0x0000 && LA3_1<='=')||(LA3_1>='?' && LA3_1<=0xFFFF)) ) {
                    alt3=1;
                }


            }
            else if ( ((LA3_0>=0x0000 && LA3_0<='$')||(LA3_0>='&' && LA3_0<=0xFFFF)) ) {
                alt3=1;
            }


            switch (alt3) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:386:36: . // alt
                    {
                    [self matchAny]; 


                    }
                    break;

                default :
                    goto loop3;
            }
        } while (YES);
        loop3: ;

        [self matchString:@"%>"]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "BIGSTRING_NO_NL" */

// $ANTLR start "BIGSTRING"
- (void) mBIGSTRING
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = BIGSTRING;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:390:2: ( '<<' ( options {greedy=false; } : '\\\\' '>' | '\\\\' ~ '>' | ~ '\\\\' )* '>>' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:390:4: '<<' ( options {greedy=false; } : '\\\\' '>' | '\\\\' ~ '>' | ~ '\\\\' )* '>>' // alt
        {
        [self matchString:@"<<"]; 

        do {
            NSInteger alt4=4;
            NSInteger LA4_0 = [input LA:1];
            if ( (LA4_0=='>') ) {
                NSInteger LA4_1 = [input LA:2];
                if ( (LA4_1=='>') ) {
                    alt4=4;
                }
                else if ( ((LA4_1>=0x0000 && LA4_1<='=')||(LA4_1>='?' && LA4_1<=0xFFFF)) ) {
                    alt4=3;
                }


            }
            else if ( (LA4_0=='\\') ) {
                NSInteger LA4_2 = [input LA:2];
                if ( (LA4_2=='>') ) {
                    alt4=1;
                }
                else if ( ((LA4_2>=0x0000 && LA4_2<='=')||(LA4_2>='?' && LA4_2<=0xFFFF)) ) {
                    alt4=2;
                }


            }
            else if ( ((LA4_0>=0x0000 && LA4_0<='=')||(LA4_0>='?' && LA4_0<='[')||(LA4_0>=']' && LA4_0<=0xFFFF)) ) {
                alt4=3;
            }


            switch (alt4) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:392:5: '\\\\' '>' // alt
                    {
                    [self matchChar:'\\']; 

                    [self matchChar:'>']; 


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:393:5: '\\\\' ~ '>' // alt
                    {
                    [self matchChar:'\\']; 

                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '='))||(([input LA:1] >= '?') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;
                case 3 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:394:5: ~ '\\\\' // alt
                    {
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '['))||(([input LA:1] >= ']') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;

                default :
                    goto loop4;
            }
        } while (YES);
        loop4: ;

        [self matchString:@">>"]; 


                NSString *txt = [[self getText] stringByReplacingOccurrencesOfString:@"\\\\>" withString:@">"];
        		[self setText:txt];
        		

        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "BIGSTRING" */

// $ANTLR start "ANONYMOUS_TEMPLATE"
- (void) mANONYMOUS_TEMPLATE
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = ANONYMOUS_TEMPLATE;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:404:5: ( '{' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:404:7: '{' // alt
        {
        [self matchChar:'{']; 


        		STToken *templateToken = [STToken newToken:input
        		                                      Type:ANONYMOUS_TEMPLATE
                                                   Channel:0
        		                                     Start:[input getIndex]
        		                                      Stop:[input getIndex]];
        		STLexer *lexer = [STLexer newSTLexer:group.errMgr
        			                           input:input
                                       templateToken:templateToken
        			              delimiterStartChar:group.delimiterStartChar
        			               delimiterStopChar:group.delimiterStopChar];
        		[lexer setSubtemplateDepth:1];
        		STToken *t = [lexer nextToken];
        		while ( [lexer subtemplateDepth] >= 1 || t.type != STLexer.RCURLY ) {
        			if ( [t getType] == STLexer.EOF_TYPE ) {
                    	ANTLRMismatchedTokenException *e = [ANTLRMismatchedTokenException newException:'}' Stream:input];
        				NSString *msg = @"missing final '}' in {...} anonymous template";
            			[group.errMgr groupLexerError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
        				break;
        			}
        			t = [lexer nextToken];
        		}
        		

        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "ANONYMOUS_TEMPLATE" */

// $ANTLR start "COMMENT"
- (void) mCOMMENT
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = COMMENT;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:433:5: ( '/*' ( options {greedy=false; } : . )* '*/' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:433:9: '/*' ( options {greedy=false; } : . )* '*/' // alt
        {
        [self matchString:@"/*"]; 

        do {
            NSInteger alt5=2;
            NSInteger LA5_0 = [input LA:1];
            if ( (LA5_0=='*') ) {
                NSInteger LA5_1 = [input LA:2];
                if ( (LA5_1=='/') ) {
                    alt5=2;
                }
                else if ( ((LA5_1>=0x0000 && LA5_1<='.')||(LA5_1>='0' && LA5_1<=0xFFFF)) ) {
                    alt5=1;
                }


            }
            else if ( ((LA5_0>=0x0000 && LA5_0<=')')||(LA5_0>='+' && LA5_0<=0xFFFF)) ) {
                alt5=1;
            }


            switch (alt5) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:433:42: . // alt
                    {
                    [self matchAny]; 


                    }
                    break;

                default :
                    goto loop5;
            }
        } while (YES);
        loop5: ;

        [self matchString:@"*/"]; 

         [self skip]; 

        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "COMMENT" */

// $ANTLR start "LINE_COMMENT"
- (void) mLINE_COMMENT
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = LINE_COMMENT;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:437:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:437:7: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' // alt
        {
        [self matchString:@"//"]; 

        do {
            NSInteger alt6=2;
            NSInteger LA6_0 = [input LA:1];
            if ( ((LA6_0>=0x0000 && LA6_0<='\t')||(LA6_0>=0x000B && LA6_0<='\f')||(LA6_0>=0x000E && LA6_0<=0xFFFF)) ) {
                alt6=1;
            }


            switch (alt6) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:437:12: ~ ( '\\n' | '\\r' ) // alt
                    {
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '\t'))||(([input LA:1] >= 0x000B) && ([input LA:1] <= '\f'))||(([input LA:1] >= 0x000E) && ([input LA:1] <= 0xFFFF))) {
                        [input consume];

                    } else {
                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;

                default :
                    goto loop6;
            }
        } while (YES);
        loop6: ;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:437:26: ( '\\r' )? // block
        NSInteger alt7=2;
        NSInteger LA7_0 = [input LA:1];

        if ( (LA7_0=='\r') ) {
            alt7=1;
        }
        switch (alt7) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:437:26: '\\r' // alt
                {
                [self matchChar:'\r']; 


                }
                break;

        }

        [self matchChar:'\n']; 

         [self skip]; 

        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "LINE_COMMENT" */

// $ANTLR start "WS"
- (void) mWS
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = WS;
        NSInteger _channel = ANTLRTokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:440:5: ( ( ' ' | '\\r' | '\\t' | '\\n' ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:440:7: ( ' ' | '\\r' | '\\t' | '\\n' ) // alt
        {
        if ((([input LA:1] >= '\t') && ([input LA:1] <= '\n'))||[input LA:1] == '\r'||[input LA:1] == ' ') {
            [input consume];

        } else {
            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
            [self recover:mse];
            @throw mse;}

         [self skip]; 

        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
/* $ANTLR end "WS" */

- (void) mTokens
{
    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:8: ( T_TRUE | T_FALSE | T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | ID | STRING | BIGSTRING_NO_NL | BIGSTRING | ANONYMOUS_TEMPLATE | COMMENT | LINE_COMMENT | WS ) //ruleblock
    NSInteger alt8=25;
    alt8 = [dfa8 predict:input];
    switch (alt8) {
        case 1 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:10: T_TRUE // alt
            {
            [self mT_TRUE]; 


            }
            break;
        case 2 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:17: T_FALSE // alt
            {
            [self mT_FALSE]; 


            }
            break;
        case 3 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:25: T__14 // alt
            {
            [self mT__14]; 


            }
            break;
        case 4 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:31: T__15 // alt
            {
            [self mT__15]; 


            }
            break;
        case 5 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:37: T__16 // alt
            {
            [self mT__16]; 


            }
            break;
        case 6 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:43: T__17 // alt
            {
            [self mT__17]; 


            }
            break;
        case 7 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:49: T__18 // alt
            {
            [self mT__18]; 


            }
            break;
        case 8 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:55: T__19 // alt
            {
            [self mT__19]; 


            }
            break;
        case 9 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:61: T__20 // alt
            {
            [self mT__20]; 


            }
            break;
        case 10 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:67: T__21 // alt
            {
            [self mT__21]; 


            }
            break;
        case 11 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:73: T__22 // alt
            {
            [self mT__22]; 


            }
            break;
        case 12 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:79: T__23 // alt
            {
            [self mT__23]; 


            }
            break;
        case 13 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:85: T__24 // alt
            {
            [self mT__24]; 


            }
            break;
        case 14 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:91: T__25 // alt
            {
            [self mT__25]; 


            }
            break;
        case 15 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:97: T__26 // alt
            {
            [self mT__26]; 


            }
            break;
        case 16 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:103: T__27 // alt
            {
            [self mT__27]; 


            }
            break;
        case 17 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:109: T__28 // alt
            {
            [self mT__28]; 


            }
            break;
        case 18 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:115: ID // alt
            {
            [self mID]; 


            }
            break;
        case 19 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:118: STRING // alt
            {
            [self mSTRING]; 


            }
            break;
        case 20 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:125: BIGSTRING_NO_NL // alt
            {
            [self mBIGSTRING_NO_NL]; 


            }
            break;
        case 21 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:141: BIGSTRING // alt
            {
            [self mBIGSTRING]; 


            }
            break;
        case 22 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:151: ANONYMOUS_TEMPLATE // alt
            {
            [self mANONYMOUS_TEMPLATE]; 


            }
            break;
        case 23 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:170: COMMENT // alt
            {
            [self mCOMMENT]; 


            }
            break;
        case 24 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:178: LINE_COMMENT // alt
            {
            [self mLINE_COMMENT]; 


            }
            break;
        case 25 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:191: WS // alt
            {
            [self mWS]; 


            }
            break;

    }

}

@end /* end of GroupLexer implementation line 397 */