/** \file
 *  This OBJC source file was generated by $ANTLR version 3.3.1-SNAPSHOT Feb 24, 2011 11:25:29
 *
 *     -  From the grammar source file : /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g
 *     -                            On : 2011-02-24 11:32:23
 *     -                for the parser : STParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2010 Alan Condit
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// $ANTLR 3.3.1-SNAPSHOT Feb 24, 2011 11:25:29 /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g 2011-02-24 11:32:23


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "STParser.h"
/* ----------------------------------------- */

/** Build an AST from a single StringTemplate template */

/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */
#pragma mark Cyclic DFA implementation start DFA2
@implementation DFA2
const static NSInteger dfa2_eot[10] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa2_eof[10] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static unichar dfa2_min[10] =
    {22,0,4,0,0,0,8,0,14,0};
const static unichar dfa2_max[10] =
    {32,0,33,0,0,0,25,0,24,0};
const static NSInteger dfa2_accept[10] =
    {-1,1,-1,4,6,2,-1,3,-1,5};
const static NSInteger dfa2_special[10] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa2_transition[] = {};
const static NSInteger dfa2_transition0[] = {5, -1, -1, -1, 7, -1, -1, -1, 
 -1, -1, 7, -1, 7, -1, -1, -1, 7, -1, -1, -1, -1, 7, 7, -1, -1, -1, -1, 
 -1, -1, 6};
const static NSInteger dfa2_transition1[] = {7, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, 9};
const static NSInteger dfa2_transition2[] = {7, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8};
const static NSInteger dfa2_transition3[] = {3, 2, -1, -1, -1, -1, -1, -1, 
 -1, 1, 4};


+ (id) newDFA2WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
{
    return [[[DFA2 alloc] initWithRecognizer:aRecognizer] retain];
}

- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
{
    if ((self = [super initWithRecognizer:theRecognizer]) != nil) {
        decisionNumber = 2;
        eot = dfa2_eot;
        eof = dfa2_eof;
        min = dfa2_min;
        max = dfa2_max;
        accept = dfa2_accept;
        special = dfa2_special;
        if (!(transition = calloc(10, sizeof(void*)))) {
            [self release];
            return nil;
        }
        len = 10;
        transition[0] = dfa2_transition3;
        transition[1] = dfa2_transition;
        transition[2] = dfa2_transition0;
        transition[3] = dfa2_transition;
        transition[4] = dfa2_transition;
        transition[5] = dfa2_transition;
        transition[6] = dfa2_transition2;
        transition[7] = dfa2_transition;
        transition[8] = dfa2_transition1;
        transition[9] = dfa2_transition;
    }
    return self;
}

- (void) dealloc
{
    free(transition);
    [super dealloc];
}

- (NSString *) description
{
    return @"104:1: element : ( INDENT element -> ^( INDENT element ) | ifstat | exprTag | text | region | NEWLINE );";
}


@end /* end DFA2 implementation */

#pragma mark Cyclic DFA implementation end DFA2

#pragma mark Cyclic DFA implementation start DFA28
@implementation DFA28
const static NSInteger dfa28_eot[22] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa28_eof[22] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static unichar dfa28_min[22] =
    {8,9,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
const static unichar dfa28_max[22] =
    {33,30,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
const static NSInteger dfa28_accept[22] =
    {-1,-1,2,-1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,5,1,3};
const static NSInteger dfa28_special[22] =
    {-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa28_transition[] = {};
const static NSInteger dfa28_transition0[] = {2, -1, -1, -1, -1, -1, 4, 
 -1, 4, -1, -1, -1, 4, -1, -1, -1, -1, 1, 4, -1, -1, -1, -1, -1, -1, 3};
const static NSInteger dfa28_transition1[] = {4, -1, -1, -1, 4, 8, 4, -1, 
 4, 4, 4, -1, -1, -1, -1, 4, -1, -1, -1, -1, 4, 4};
const static NSInteger dfa28_transition2[] = {18, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19};
const static NSInteger dfa28_transition3[] = {-1};


+ (id) newDFA28WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
{
    return [[[DFA28 alloc] initWithRecognizer:aRecognizer] retain];
}

- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
{
    if ((self = [super initWithRecognizer:theRecognizer]) != nil) {
        decisionNumber = 28;
        eot = dfa28_eot;
        eof = dfa28_eof;
        min = dfa28_min;
        max = dfa28_max;
        accept = dfa28_accept;
        special = dfa28_special;
        if (!(transition = calloc(22, sizeof(void*)))) {
            [self release];
            return nil;
        }
        len = 22;
        transition[0] = dfa28_transition0;
        transition[1] = dfa28_transition1;
        transition[2] = dfa28_transition;
        transition[3] = dfa28_transition2;
        transition[4] = dfa28_transition;
        transition[5] = dfa28_transition;
        transition[6] = dfa28_transition;
        transition[7] = dfa28_transition;
        transition[8] = dfa28_transition3;
        transition[9] = dfa28_transition;
        transition[10] = dfa28_transition;
        transition[11] = dfa28_transition;
        transition[12] = dfa28_transition;
        transition[13] = dfa28_transition;
        transition[14] = dfa28_transition;
        transition[15] = dfa28_transition;
        transition[16] = dfa28_transition;
        transition[17] = dfa28_transition;
        transition[18] = dfa28_transition;
        transition[19] = dfa28_transition;
        transition[20] = dfa28_transition;
        transition[21] = dfa28_transition;
    }
    return self;
}

/* start dfa.specialStateSTs */
- (NSInteger) specialStateTransition:(NSInteger)s Stream:(id<ANTLRIntStream>)anInput
{
    id<ANTLRTokenStream> input = (id<ANTLRTokenStream>)anInput;
    switch (s) {
                case 0 : ;
                    /* cyclicDFAState */
                    NSInteger LA28_8 = [input LA:1];

                     
                    NSInteger index28_8 = [input getIndex];
                    [input rewind];
                    s = -1;
                    /* cyclicDFAEdge */
                    if (([[Compiler funcs] objectForKey:[[input LT:1] getText]])) { s = 20;}

                    else /* cyclicDFAEdge */
                    if (YES) { s = 21;}

                     
                    [input seek:index28_8];
                    if ( s >= 0 )
                        return s;
                     break;
    }
    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:28 state:s stream:[recognizer getInput]];
    /* [self error:nvae]; */ 
    @throw nvae;
}

/* end dfa.specialStateSTs */
- (void) dealloc
{
    free(transition);
    [super dealloc];
}

- (NSString *) description
{
    return @"221:1: includeExpr options {k=2; } : ({...}? ID '(' ( expr )? ')' -> ^( EXEC_FUNC ID ( expr )? ) | 'super' '.' ID '(' args ')' -> ^( INCLUDE_SUPER ID ( args )? ) | ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | '@' 'super' '.' ID '(' rp= ')' -> ^( INCLUDE_SUPER_REGION ID ) | '@' ID '(' rp= ')' -> ^( INCLUDE_REGION ID ) | primary );";
}


@end /* end DFA28 implementation */

#pragma mark Cyclic DFA implementation end DFA28



#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_template_in_templateAndEOF187;
static const unsigned long long FOLLOW_template_in_templateAndEOF187_data[] = { 0x0000000000000000LL};
static ANTLRBitSet *FOLLOW_EOF_in_templateAndEOF189;
static const unsigned long long FOLLOW_EOF_in_templateAndEOF189_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_element_in_template203;
static const unsigned long long FOLLOW_element_in_template203_data[] = { 0x0000000180C00002LL};
static ANTLRBitSet *FOLLOW_INDENT_in_element219;
static const unsigned long long FOLLOW_INDENT_in_element219_data[] = { 0x0000000180C00000LL};
static ANTLRBitSet *FOLLOW_element_in_element221;
static const unsigned long long FOLLOW_element_in_element221_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ifstat_in_element239;
static const unsigned long long FOLLOW_ifstat_in_element239_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_exprTag_in_element249;
static const unsigned long long FOLLOW_exprTag_in_element249_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_text_in_element259;
static const unsigned long long FOLLOW_text_in_element259_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_region_in_element269;
static const unsigned long long FOLLOW_region_in_element269_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_element279;
static const unsigned long long FOLLOW_NEWLINE_in_element279_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_TEXT_in_text292;
static const unsigned long long FOLLOW_TEXT_in_text292_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_exprTag307;
static const unsigned long long FOLLOW_LDELIM_in_exprTag307_data[] = { 0x0000000206114100LL};
static ANTLRBitSet *FOLLOW_expr_in_exprTag309;
static const unsigned long long FOLLOW_expr_in_exprTag309_data[] = { 0x0000000001000200LL};
static ANTLRBitSet *FOLLOW_SEMI_in_exprTag313;
static const unsigned long long FOLLOW_SEMI_in_exprTag313_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_exprOptions_in_exprTag315;
static const unsigned long long FOLLOW_exprOptions_in_exprTag315_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_exprTag320;
static const unsigned long long FOLLOW_RDELIM_in_exprTag320_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_region353;
static const unsigned long long FOLLOW_LDELIM_in_region353_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_AT_in_region355;
static const unsigned long long FOLLOW_AT_in_region355_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_ID_in_region357;
static const unsigned long long FOLLOW_ID_in_region357_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_region359;
static const unsigned long long FOLLOW_RDELIM_in_region359_data[] = { 0x0000000180C00000LL};
static ANTLRBitSet *FOLLOW_template_in_region361;
static const unsigned long long FOLLOW_template_in_region361_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_region363;
static const unsigned long long FOLLOW_LDELIM_in_region363_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_REGION_END_in_region365;
static const unsigned long long FOLLOW_REGION_END_in_region365_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_region367;
static const unsigned long long FOLLOW_RDELIM_in_region367_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LCURLY_in_subtemplate394;
static const unsigned long long FOLLOW_LCURLY_in_subtemplate394_data[] = { 0x0000000182C00000LL};
static ANTLRBitSet *FOLLOW_ID_in_subtemplate400;
static const unsigned long long FOLLOW_ID_in_subtemplate400_data[] = { 0x0000000010040000LL};
static ANTLRBitSet *FOLLOW_COMMA_in_subtemplate404;
static const unsigned long long FOLLOW_COMMA_in_subtemplate404_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_ID_in_subtemplate409;
static const unsigned long long FOLLOW_ID_in_subtemplate409_data[] = { 0x0000000010040000LL};
static ANTLRBitSet *FOLLOW_PIPE_in_subtemplate414;
static const unsigned long long FOLLOW_PIPE_in_subtemplate414_data[] = { 0x0000000180C00000LL};
static ANTLRBitSet *FOLLOW_template_in_subtemplate419;
static const unsigned long long FOLLOW_template_in_subtemplate419_data[] = { 0x0000000080200000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_subtemplate421;
static const unsigned long long FOLLOW_INDENT_in_subtemplate421_data[] = { 0x0000000000200000LL};
static ANTLRBitSet *FOLLOW_RCURLY_in_subtemplate424;
static const unsigned long long FOLLOW_RCURLY_in_subtemplate424_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat478;
static const unsigned long long FOLLOW_LDELIM_in_ifstat478_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_IF_in_ifstat480;
static const unsigned long long FOLLOW_IF_in_ifstat480_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_ifstat482;
static const unsigned long long FOLLOW_LPAREN_in_ifstat482_data[] = { 0x0000000206114500LL};
static ANTLRBitSet *FOLLOW_conditional_in_ifstat486;
static const unsigned long long FOLLOW_conditional_in_ifstat486_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_ifstat488;
static const unsigned long long FOLLOW_RPAREN_in_ifstat488_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat490;
static const unsigned long long FOLLOW_RDELIM_in_ifstat490_data[] = { 0x0000000180C00000LL};
static ANTLRBitSet *FOLLOW_template_in_ifstat506;
static const unsigned long long FOLLOW_template_in_ifstat506_data[] = { 0x0000000080800000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat522;
static const unsigned long long FOLLOW_INDENT_in_ifstat522_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat525;
static const unsigned long long FOLLOW_LDELIM_in_ifstat525_data[] = { 0x0000000000000040LL};
static ANTLRBitSet *FOLLOW_ELSEIF_in_ifstat527;
static const unsigned long long FOLLOW_ELSEIF_in_ifstat527_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_ifstat529;
static const unsigned long long FOLLOW_LPAREN_in_ifstat529_data[] = { 0x0000000206114500LL};
static ANTLRBitSet *FOLLOW_conditional_in_ifstat533;
static const unsigned long long FOLLOW_conditional_in_ifstat533_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_ifstat535;
static const unsigned long long FOLLOW_RPAREN_in_ifstat535_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat537;
static const unsigned long long FOLLOW_RDELIM_in_ifstat537_data[] = { 0x0000000180C00000LL};
static ANTLRBitSet *FOLLOW_template_in_ifstat541;
static const unsigned long long FOLLOW_template_in_ifstat541_data[] = { 0x0000000080800000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat560;
static const unsigned long long FOLLOW_INDENT_in_ifstat560_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat563;
static const unsigned long long FOLLOW_LDELIM_in_ifstat563_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_ELSE_in_ifstat565;
static const unsigned long long FOLLOW_ELSE_in_ifstat565_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat567;
static const unsigned long long FOLLOW_RDELIM_in_ifstat567_data[] = { 0x0000000180C00000LL};
static ANTLRBitSet *FOLLOW_template_in_ifstat571;
static const unsigned long long FOLLOW_template_in_ifstat571_data[] = { 0x0000000080800000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat588;
static const unsigned long long FOLLOW_INDENT_in_ifstat588_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat594;
static const unsigned long long FOLLOW_LDELIM_in_ifstat594_data[] = { 0x0000000000000080LL};
static ANTLRBitSet *FOLLOW_ENDIF_in_ifstat596;
static const unsigned long long FOLLOW_ENDIF_in_ifstat596_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat606;
static const unsigned long long FOLLOW_RDELIM_in_ifstat606_data[] = { 0x0000000100000002LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_ifstat629;
static const unsigned long long FOLLOW_NEWLINE_in_ifstat629_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_andConditional_in_conditional685;
static const unsigned long long FOLLOW_andConditional_in_conditional685_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_OR_in_conditional689;
static const unsigned long long FOLLOW_OR_in_conditional689_data[] = { 0x0000000206114500LL};
static ANTLRBitSet *FOLLOW_andConditional_in_conditional692;
static const unsigned long long FOLLOW_andConditional_in_conditional692_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_notConditional_in_andConditional704;
static const unsigned long long FOLLOW_notConditional_in_andConditional704_data[] = { 0x0000000040000002LL};
static ANTLRBitSet *FOLLOW_AND_in_andConditional708;
static const unsigned long long FOLLOW_AND_in_andConditional708_data[] = { 0x0000000206114500LL};
static ANTLRBitSet *FOLLOW_notConditional_in_andConditional711;
static const unsigned long long FOLLOW_notConditional_in_andConditional711_data[] = { 0x0000000040000002LL};
static ANTLRBitSet *FOLLOW_BANG_in_notConditional725;
static const unsigned long long FOLLOW_BANG_in_notConditional725_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_notConditionalExpr_in_notConditional728;
static const unsigned long long FOLLOW_notConditionalExpr_in_notConditional728_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_BANG_in_notConditional732;
static const unsigned long long FOLLOW_BANG_in_notConditional732_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_notConditional735;
static const unsigned long long FOLLOW_LPAREN_in_notConditional735_data[] = { 0x0000000206114500LL};
static ANTLRBitSet *FOLLOW_conditional_in_notConditional738;
static const unsigned long long FOLLOW_conditional_in_notConditional738_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_notConditional740;
static const unsigned long long FOLLOW_RPAREN_in_notConditional740_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_notConditional745;
static const unsigned long long FOLLOW_memberExpr_in_notConditional745_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_notConditionalExpr762;
static const unsigned long long FOLLOW_ID_in_notConditionalExpr762_data[] = { 0x0000000000080002LL};
static ANTLRBitSet *FOLLOW_DOT_in_notConditionalExpr781;
static const unsigned long long FOLLOW_DOT_in_notConditionalExpr781_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_ID_in_notConditionalExpr785;
static const unsigned long long FOLLOW_ID_in_notConditionalExpr785_data[] = { 0x0000000000080002LL};
static ANTLRBitSet *FOLLOW_DOT_in_notConditionalExpr836;
static const unsigned long long FOLLOW_DOT_in_notConditionalExpr836_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_notConditionalExpr838;
static const unsigned long long FOLLOW_LPAREN_in_notConditionalExpr838_data[] = { 0x0000000206114100LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_notConditionalExpr840;
static const unsigned long long FOLLOW_mapExpr_in_notConditionalExpr840_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_notConditionalExpr842;
static const unsigned long long FOLLOW_RPAREN_in_notConditionalExpr842_data[] = { 0x0000000000080002LL};
static ANTLRBitSet *FOLLOW_option_in_exprOptions892;
static const unsigned long long FOLLOW_option_in_exprOptions892_data[] = { 0x0000000000040002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_exprOptions896;
static const unsigned long long FOLLOW_COMMA_in_exprOptions896_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_option_in_exprOptions898;
static const unsigned long long FOLLOW_option_in_exprOptions898_data[] = { 0x0000000000040002LL};
static ANTLRBitSet *FOLLOW_ID_in_option930;
static const unsigned long long FOLLOW_ID_in_option930_data[] = { 0x0000000000001002LL};
static ANTLRBitSet *FOLLOW_EQUALS_in_option954;
static const unsigned long long FOLLOW_EQUALS_in_option954_data[] = { 0x0000000206114100LL};
static ANTLRBitSet *FOLLOW_exprNoComma_in_option956;
static const unsigned long long FOLLOW_exprNoComma_in_option956_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_exprNoComma1244;
static const unsigned long long FOLLOW_memberExpr_in_exprNoComma1244_data[] = { 0x0000000000002002LL};
static ANTLRBitSet *FOLLOW_COLON_in_exprNoComma1256;
static const unsigned long long FOLLOW_COLON_in_exprNoComma1256_data[] = { 0x0000000002104000LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_exprNoComma1258;
static const unsigned long long FOLLOW_mapTemplateRef_in_exprNoComma1258_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_expr1362;
static const unsigned long long FOLLOW_mapExpr_in_expr1362_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_mapExpr1379;
static const unsigned long long FOLLOW_memberExpr_in_mapExpr1379_data[] = { 0x0000000000042002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_mapExpr1394;
static const unsigned long long FOLLOW_COMMA_in_mapExpr1394_data[] = { 0x0000000206114100LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_mapExpr1396;
static const unsigned long long FOLLOW_memberExpr_in_mapExpr1396_data[] = { 0x0000000000042000LL};
static ANTLRBitSet *FOLLOW_COLON_in_mapExpr1402;
static const unsigned long long FOLLOW_COLON_in_mapExpr1402_data[] = { 0x0000000002104000LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_mapExpr1404;
static const unsigned long long FOLLOW_mapTemplateRef_in_mapExpr1404_data[] = { 0x0000000000002002LL};
static ANTLRBitSet *FOLLOW_COLON_in_mapExpr1561;
static const unsigned long long FOLLOW_COLON_in_mapExpr1561_data[] = { 0x0000000002104000LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_mapExpr1565;
static const unsigned long long FOLLOW_mapTemplateRef_in_mapExpr1565_data[] = { 0x0000000000042002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_mapExpr1571;
static const unsigned long long FOLLOW_COMMA_in_mapExpr1571_data[] = { 0x0000000002104000LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_mapExpr1575;
static const unsigned long long FOLLOW_mapTemplateRef_in_mapExpr1575_data[] = { 0x0000000000042002LL};
static ANTLRBitSet *FOLLOW_ID_in_mapTemplateRef1672;
static const unsigned long long FOLLOW_ID_in_mapTemplateRef1672_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_mapTemplateRef1674;
static const unsigned long long FOLLOW_LPAREN_in_mapTemplateRef1674_data[] = { 0x000000020611C100LL};
static ANTLRBitSet *FOLLOW_args_in_mapTemplateRef1676;
static const unsigned long long FOLLOW_args_in_mapTemplateRef1676_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_mapTemplateRef1678;
static const unsigned long long FOLLOW_RPAREN_in_mapTemplateRef1678_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_subtemplate_in_mapTemplateRef1723;
static const unsigned long long FOLLOW_subtemplate_in_mapTemplateRef1723_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_mapTemplateRef1735;
static const unsigned long long FOLLOW_LPAREN_in_mapTemplateRef1735_data[] = { 0x0000000206114100LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_mapTemplateRef1737;
static const unsigned long long FOLLOW_mapExpr_in_mapTemplateRef1737_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_mapTemplateRef1741;
static const unsigned long long FOLLOW_RPAREN_in_mapTemplateRef1741_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_mapTemplateRef1743;
static const unsigned long long FOLLOW_LPAREN_in_mapTemplateRef1743_data[] = { 0x000000020611C100LL};
static ANTLRBitSet *FOLLOW_argExprList_in_mapTemplateRef1745;
static const unsigned long long FOLLOW_argExprList_in_mapTemplateRef1745_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_mapTemplateRef1748;
static const unsigned long long FOLLOW_RPAREN_in_mapTemplateRef1748_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_includeExpr_in_memberExpr1778;
static const unsigned long long FOLLOW_includeExpr_in_memberExpr1778_data[] = { 0x0000000000080002LL};
static ANTLRBitSet *FOLLOW_DOT_in_memberExpr1797;
static const unsigned long long FOLLOW_DOT_in_memberExpr1797_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_ID_in_memberExpr1799;
static const unsigned long long FOLLOW_ID_in_memberExpr1799_data[] = { 0x0000000000080002LL};
static ANTLRBitSet *FOLLOW_DOT_in_memberExpr1854;
static const unsigned long long FOLLOW_DOT_in_memberExpr1854_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_memberExpr1856;
static const unsigned long long FOLLOW_LPAREN_in_memberExpr1856_data[] = { 0x0000000206114100LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_memberExpr1858;
static const unsigned long long FOLLOW_mapExpr_in_memberExpr1858_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_memberExpr1860;
static const unsigned long long FOLLOW_RPAREN_in_memberExpr1860_data[] = { 0x0000000000080002LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr1935;
static const unsigned long long FOLLOW_ID_in_includeExpr1935_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr1937;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr1937_data[] = { 0x000000020611C100LL};
static ANTLRBitSet *FOLLOW_expr_in_includeExpr1939;
static const unsigned long long FOLLOW_expr_in_includeExpr1939_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr1942;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr1942_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_SUPER_in_includeExpr1986;
static const unsigned long long FOLLOW_SUPER_in_includeExpr1986_data[] = { 0x0000000000080000LL};
static ANTLRBitSet *FOLLOW_DOT_in_includeExpr1988;
static const unsigned long long FOLLOW_DOT_in_includeExpr1988_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr1990;
static const unsigned long long FOLLOW_ID_in_includeExpr1990_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr1992;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr1992_data[] = { 0x000000020611C100LL};
static ANTLRBitSet *FOLLOW_args_in_includeExpr1994;
static const unsigned long long FOLLOW_args_in_includeExpr1994_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr1996;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr1996_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2029;
static const unsigned long long FOLLOW_ID_in_includeExpr2029_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2031;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2031_data[] = { 0x000000020611C100LL};
static ANTLRBitSet *FOLLOW_args_in_includeExpr2033;
static const unsigned long long FOLLOW_args_in_includeExpr2033_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2035;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2035_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_AT_in_includeExpr2080;
static const unsigned long long FOLLOW_AT_in_includeExpr2080_data[] = { 0x0000000000000100LL};
static ANTLRBitSet *FOLLOW_SUPER_in_includeExpr2082;
static const unsigned long long FOLLOW_SUPER_in_includeExpr2082_data[] = { 0x0000000000080000LL};
static ANTLRBitSet *FOLLOW_DOT_in_includeExpr2084;
static const unsigned long long FOLLOW_DOT_in_includeExpr2084_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2086;
static const unsigned long long FOLLOW_ID_in_includeExpr2086_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2088;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2088_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2092;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2092_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_AT_in_includeExpr2120;
static const unsigned long long FOLLOW_AT_in_includeExpr2120_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2122;
static const unsigned long long FOLLOW_ID_in_includeExpr2122_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2124;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2124_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2128;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2128_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_primary_in_includeExpr2168;
static const unsigned long long FOLLOW_primary_in_includeExpr2168_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_primary2187;
static const unsigned long long FOLLOW_ID_in_primary2187_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_STRING_in_primary2197;
static const unsigned long long FOLLOW_STRING_in_primary2197_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_subtemplate_in_primary2207;
static const unsigned long long FOLLOW_subtemplate_in_primary2207_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_list_in_primary2217;
static const unsigned long long FOLLOW_list_in_primary2217_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_primary2229;
static const unsigned long long FOLLOW_LPAREN_in_primary2229_data[] = { 0x0000000206114100LL};
static ANTLRBitSet *FOLLOW_expr_in_primary2231;
static const unsigned long long FOLLOW_expr_in_primary2231_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_primary2233;
static const unsigned long long FOLLOW_RPAREN_in_primary2233_data[] = { 0x0000000000004002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_primary2247;
static const unsigned long long FOLLOW_LPAREN_in_primary2247_data[] = { 0x000000020611C100LL};
static ANTLRBitSet *FOLLOW_argExprList_in_primary2249;
static const unsigned long long FOLLOW_argExprList_in_primary2249_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_primary2252;
static const unsigned long long FOLLOW_RPAREN_in_primary2252_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_argExprList_in_args2360;
static const unsigned long long FOLLOW_argExprList_in_args2360_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_namedArg_in_args2370;
static const unsigned long long FOLLOW_namedArg_in_args2370_data[] = { 0x0000000000040002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_args2374;
static const unsigned long long FOLLOW_COMMA_in_args2374_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_namedArg_in_args2376;
static const unsigned long long FOLLOW_namedArg_in_args2376_data[] = { 0x0000000000040002LL};
static ANTLRBitSet *FOLLOW_arg_in_argExprList2403;
static const unsigned long long FOLLOW_arg_in_argExprList2403_data[] = { 0x0000000000040002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_argExprList2407;
static const unsigned long long FOLLOW_COMMA_in_argExprList2407_data[] = { 0x0000000206114100LL};
static ANTLRBitSet *FOLLOW_arg_in_argExprList2409;
static const unsigned long long FOLLOW_arg_in_argExprList2409_data[] = { 0x0000000000040002LL};
static ANTLRBitSet *FOLLOW_exprNoComma_in_arg2426;
static const unsigned long long FOLLOW_exprNoComma_in_arg2426_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_namedArg2435;
static const unsigned long long FOLLOW_ID_in_namedArg2435_data[] = { 0x0000000000001000LL};
static ANTLRBitSet *FOLLOW_EQUALS_in_namedArg2437;
static const unsigned long long FOLLOW_EQUALS_in_namedArg2437_data[] = { 0x0000000206114100LL};
static ANTLRBitSet *FOLLOW_arg_in_namedArg2439;
static const unsigned long long FOLLOW_arg_in_namedArg2439_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LBRACK_in_list2472;
static const unsigned long long FOLLOW_LBRACK_in_list2472_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_RBRACK_in_list2474;
static const unsigned long long FOLLOW_RBRACK_in_list2474_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LBRACK_in_list2491;
static const unsigned long long FOLLOW_LBRACK_in_list2491_data[] = { 0x0000000206174100LL};
static ANTLRBitSet *FOLLOW_listElement_in_list2493;
static const unsigned long long FOLLOW_listElement_in_list2493_data[] = { 0x0000000000060000LL};
static ANTLRBitSet *FOLLOW_COMMA_in_list2497;
static const unsigned long long FOLLOW_COMMA_in_list2497_data[] = { 0x0000000206174100LL};
static ANTLRBitSet *FOLLOW_listElement_in_list2499;
static const unsigned long long FOLLOW_listElement_in_list2499_data[] = { 0x0000000000060000LL};
static ANTLRBitSet *FOLLOW_RBRACK_in_list2504;
static const unsigned long long FOLLOW_RBRACK_in_list2504_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_exprNoComma_in_listElement2527;
static const unsigned long long FOLLOW_exprNoComma_in_listElement2527_data[] = { 0x0000000000000002LL};


#pragma mark Dynamic Global Scopes

#pragma mark Dynamic Rule Scopes

#pragma mark Rule Return Scopes start
@implementation STParser_templateAndEOF_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_templateAndEOF_return *)newSTParser_templateAndEOF_return
{
    return [[[STParser_templateAndEOF_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_template_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_template_return *)newSTParser_template_return
{
    return [[[STParser_template_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_element_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_element_return *)newSTParser_element_return
{
    return [[[STParser_element_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_text_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_text_return *)newSTParser_text_return
{
    return [[[STParser_text_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_exprTag_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_exprTag_return *)newSTParser_exprTag_return
{
    return [[[STParser_exprTag_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_region_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_region_return *)newSTParser_region_return
{
    return [[[STParser_region_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_subtemplate_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_subtemplate_return *)newSTParser_subtemplate_return
{
    return [[[STParser_subtemplate_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_ifstat_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_ifstat_return *)newSTParser_ifstat_return
{
    return [[[STParser_ifstat_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_conditional_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_conditional_return *)newSTParser_conditional_return
{
    return [[[STParser_conditional_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_andConditional_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_andConditional_return *)newSTParser_andConditional_return
{
    return [[[STParser_andConditional_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_notConditional_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_notConditional_return *)newSTParser_notConditional_return
{
    return [[[STParser_notConditional_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_notConditionalExpr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_notConditionalExpr_return *)newSTParser_notConditionalExpr_return
{
    return [[[STParser_notConditionalExpr_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_exprOptions_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_exprOptions_return *)newSTParser_exprOptions_return
{
    return [[[STParser_exprOptions_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_option_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_option_return *)newSTParser_option_return
{
    return [[[STParser_option_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_exprNoComma_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_exprNoComma_return *)newSTParser_exprNoComma_return
{
    return [[[STParser_exprNoComma_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_expr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_expr_return *)newSTParser_expr_return
{
    return [[[STParser_expr_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_mapExpr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_mapExpr_return *)newSTParser_mapExpr_return
{
    return [[[STParser_mapExpr_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_mapTemplateRef_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_mapTemplateRef_return *)newSTParser_mapTemplateRef_return
{
    return [[[STParser_mapTemplateRef_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_memberExpr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_memberExpr_return *)newSTParser_memberExpr_return
{
    return [[[STParser_memberExpr_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_includeExpr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_includeExpr_return *)newSTParser_includeExpr_return
{
    return [[[STParser_includeExpr_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_primary_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_primary_return *)newSTParser_primary_return
{
    return [[[STParser_primary_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_args_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_args_return *)newSTParser_args_return
{
    return [[[STParser_args_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_argExprList_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_argExprList_return *)newSTParser_argExprList_return
{
    return [[[STParser_argExprList_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_arg_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_arg_return *)newSTParser_arg_return
{
    return [[[STParser_arg_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_namedArg_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_namedArg_return *)newSTParser_namedArg_return
{
    return [[[STParser_namedArg_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_list_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_list_return *)newSTParser_list_return
{
    return [[[STParser_list_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */
@implementation STParser_listElement_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_listElement_return *)newSTParser_listElement_return
{
    return [[[STParser_listElement_return alloc] init] retain];
}

- (id) init
{
    if (self = [super init]) {
    }
    return self;
}

/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
    return tree;
}

- (void) setTree:(ANTLRCommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */

//#pragma mark Rule return scopes start
//

#pragma mark Rule return scopes start

@implementation STParser  // line 637

/* ObjC start of ruleAttributeScope */
#pragma mark Dynamic Rule Scopes
/* ObjC end of ruleAttributeScope */
#pragma mark global Attribute Scopes
/* ObjC start globalAttributeScope */
/* ObjC end globalAttributeScope */
/* ObjC start actions.(actionScope).synthesize */

@synthesize errMgr;
@synthesize templateToken;

/* ObjC end actions.(actionScope).synthesize */
/* ObjC start synthesize() */
/* AST genericParser.synthesize */
/* AST parserProperties */
@synthesize treeAdaptor;
/* ObjC end synthesize() */

+ (void) initialize
{
    #pragma mark Bitsets
    FOLLOW_template_in_templateAndEOF187 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_templateAndEOF187_data Count:(NSUInteger)1] retain];
    FOLLOW_EOF_in_templateAndEOF189 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_EOF_in_templateAndEOF189_data Count:(NSUInteger)1] retain];
    FOLLOW_element_in_template203 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_element_in_template203_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_element219 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_element219_data Count:(NSUInteger)1] retain];
    FOLLOW_element_in_element221 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_element_in_element221_data Count:(NSUInteger)1] retain];
    FOLLOW_ifstat_in_element239 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ifstat_in_element239_data Count:(NSUInteger)1] retain];
    FOLLOW_exprTag_in_element249 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_exprTag_in_element249_data Count:(NSUInteger)1] retain];
    FOLLOW_text_in_element259 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_text_in_element259_data Count:(NSUInteger)1] retain];
    FOLLOW_region_in_element269 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_region_in_element269_data Count:(NSUInteger)1] retain];
    FOLLOW_NEWLINE_in_element279 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_element279_data Count:(NSUInteger)1] retain];
    FOLLOW_TEXT_in_text292 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_TEXT_in_text292_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_exprTag307 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_exprTag307_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_exprTag309 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_exprTag309_data Count:(NSUInteger)1] retain];
    FOLLOW_SEMI_in_exprTag313 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_SEMI_in_exprTag313_data Count:(NSUInteger)1] retain];
    FOLLOW_exprOptions_in_exprTag315 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_exprOptions_in_exprTag315_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_exprTag320 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_exprTag320_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_region353 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_region353_data Count:(NSUInteger)1] retain];
    FOLLOW_AT_in_region355 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_AT_in_region355_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_region357 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_region357_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_region359 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_region359_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_region361 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_region361_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_region363 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_region363_data Count:(NSUInteger)1] retain];
    FOLLOW_REGION_END_in_region365 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_REGION_END_in_region365_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_region367 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_region367_data Count:(NSUInteger)1] retain];
    FOLLOW_LCURLY_in_subtemplate394 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LCURLY_in_subtemplate394_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_subtemplate400 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_subtemplate400_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_subtemplate404 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_subtemplate404_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_subtemplate409 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_subtemplate409_data Count:(NSUInteger)1] retain];
    FOLLOW_PIPE_in_subtemplate414 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_PIPE_in_subtemplate414_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_subtemplate419 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_subtemplate419_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_subtemplate421 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_subtemplate421_data Count:(NSUInteger)1] retain];
    FOLLOW_RCURLY_in_subtemplate424 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RCURLY_in_subtemplate424_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_ifstat478 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat478_data Count:(NSUInteger)1] retain];
    FOLLOW_IF_in_ifstat480 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_IF_in_ifstat480_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_ifstat482 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_ifstat482_data Count:(NSUInteger)1] retain];
    FOLLOW_conditional_in_ifstat486 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_conditional_in_ifstat486_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_ifstat488 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_ifstat488_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_ifstat490 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat490_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_ifstat506 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_ifstat506_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_ifstat522 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat522_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_ifstat525 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat525_data Count:(NSUInteger)1] retain];
    FOLLOW_ELSEIF_in_ifstat527 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ELSEIF_in_ifstat527_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_ifstat529 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_ifstat529_data Count:(NSUInteger)1] retain];
    FOLLOW_conditional_in_ifstat533 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_conditional_in_ifstat533_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_ifstat535 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_ifstat535_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_ifstat537 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat537_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_ifstat541 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_ifstat541_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_ifstat560 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat560_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_ifstat563 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat563_data Count:(NSUInteger)1] retain];
    FOLLOW_ELSE_in_ifstat565 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ELSE_in_ifstat565_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_ifstat567 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat567_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_ifstat571 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_ifstat571_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_ifstat588 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat588_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_ifstat594 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat594_data Count:(NSUInteger)1] retain];
    FOLLOW_ENDIF_in_ifstat596 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ENDIF_in_ifstat596_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_ifstat606 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat606_data Count:(NSUInteger)1] retain];
    FOLLOW_NEWLINE_in_ifstat629 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_ifstat629_data Count:(NSUInteger)1] retain];
    FOLLOW_andConditional_in_conditional685 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_andConditional_in_conditional685_data Count:(NSUInteger)1] retain];
    FOLLOW_OR_in_conditional689 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_OR_in_conditional689_data Count:(NSUInteger)1] retain];
    FOLLOW_andConditional_in_conditional692 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_andConditional_in_conditional692_data Count:(NSUInteger)1] retain];
    FOLLOW_notConditional_in_andConditional704 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_notConditional_in_andConditional704_data Count:(NSUInteger)1] retain];
    FOLLOW_AND_in_andConditional708 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_AND_in_andConditional708_data Count:(NSUInteger)1] retain];
    FOLLOW_notConditional_in_andConditional711 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_notConditional_in_andConditional711_data Count:(NSUInteger)1] retain];
    FOLLOW_BANG_in_notConditional725 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_BANG_in_notConditional725_data Count:(NSUInteger)1] retain];
    FOLLOW_notConditionalExpr_in_notConditional728 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_notConditionalExpr_in_notConditional728_data Count:(NSUInteger)1] retain];
    FOLLOW_BANG_in_notConditional732 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_BANG_in_notConditional732_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_notConditional735 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_notConditional735_data Count:(NSUInteger)1] retain];
    FOLLOW_conditional_in_notConditional738 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_conditional_in_notConditional738_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_notConditional740 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_notConditional740_data Count:(NSUInteger)1] retain];
    FOLLOW_memberExpr_in_notConditional745 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_notConditional745_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_notConditionalExpr762 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_notConditionalExpr762_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_notConditionalExpr781 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_notConditionalExpr781_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_notConditionalExpr785 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_notConditionalExpr785_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_notConditionalExpr836 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_notConditionalExpr836_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_notConditionalExpr838 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_notConditionalExpr838_data Count:(NSUInteger)1] retain];
    FOLLOW_mapExpr_in_notConditionalExpr840 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_notConditionalExpr840_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_notConditionalExpr842 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_notConditionalExpr842_data Count:(NSUInteger)1] retain];
    FOLLOW_option_in_exprOptions892 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_option_in_exprOptions892_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_exprOptions896 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_exprOptions896_data Count:(NSUInteger)1] retain];
    FOLLOW_option_in_exprOptions898 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_option_in_exprOptions898_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_option930 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_option930_data Count:(NSUInteger)1] retain];
    FOLLOW_EQUALS_in_option954 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_EQUALS_in_option954_data Count:(NSUInteger)1] retain];
    FOLLOW_exprNoComma_in_option956 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_exprNoComma_in_option956_data Count:(NSUInteger)1] retain];
    FOLLOW_memberExpr_in_exprNoComma1244 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_exprNoComma1244_data Count:(NSUInteger)1] retain];
    FOLLOW_COLON_in_exprNoComma1256 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COLON_in_exprNoComma1256_data Count:(NSUInteger)1] retain];
    FOLLOW_mapTemplateRef_in_exprNoComma1258 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_exprNoComma1258_data Count:(NSUInteger)1] retain];
    FOLLOW_mapExpr_in_expr1362 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_expr1362_data Count:(NSUInteger)1] retain];
    FOLLOW_memberExpr_in_mapExpr1379 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_mapExpr1379_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_mapExpr1394 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_mapExpr1394_data Count:(NSUInteger)1] retain];
    FOLLOW_memberExpr_in_mapExpr1396 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_mapExpr1396_data Count:(NSUInteger)1] retain];
    FOLLOW_COLON_in_mapExpr1402 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COLON_in_mapExpr1402_data Count:(NSUInteger)1] retain];
    FOLLOW_mapTemplateRef_in_mapExpr1404 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_mapExpr1404_data Count:(NSUInteger)1] retain];
    FOLLOW_COLON_in_mapExpr1561 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COLON_in_mapExpr1561_data Count:(NSUInteger)1] retain];
    FOLLOW_mapTemplateRef_in_mapExpr1565 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_mapExpr1565_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_mapExpr1571 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_mapExpr1571_data Count:(NSUInteger)1] retain];
    FOLLOW_mapTemplateRef_in_mapExpr1575 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_mapExpr1575_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_mapTemplateRef1672 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_mapTemplateRef1672_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_mapTemplateRef1674 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_mapTemplateRef1674_data Count:(NSUInteger)1] retain];
    FOLLOW_args_in_mapTemplateRef1676 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_args_in_mapTemplateRef1676_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_mapTemplateRef1678 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_mapTemplateRef1678_data Count:(NSUInteger)1] retain];
    FOLLOW_subtemplate_in_mapTemplateRef1723 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_subtemplate_in_mapTemplateRef1723_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_mapTemplateRef1735 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_mapTemplateRef1735_data Count:(NSUInteger)1] retain];
    FOLLOW_mapExpr_in_mapTemplateRef1737 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_mapTemplateRef1737_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_mapTemplateRef1741 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_mapTemplateRef1741_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_mapTemplateRef1743 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_mapTemplateRef1743_data Count:(NSUInteger)1] retain];
    FOLLOW_argExprList_in_mapTemplateRef1745 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_argExprList_in_mapTemplateRef1745_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_mapTemplateRef1748 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_mapTemplateRef1748_data Count:(NSUInteger)1] retain];
    FOLLOW_includeExpr_in_memberExpr1778 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_includeExpr_in_memberExpr1778_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_memberExpr1797 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_memberExpr1797_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_memberExpr1799 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_memberExpr1799_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_memberExpr1854 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_memberExpr1854_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_memberExpr1856 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_memberExpr1856_data Count:(NSUInteger)1] retain];
    FOLLOW_mapExpr_in_memberExpr1858 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_memberExpr1858_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_memberExpr1860 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_memberExpr1860_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr1935 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr1935_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr1937 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr1937_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_includeExpr1939 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_includeExpr1939_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr1942 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr1942_data Count:(NSUInteger)1] retain];
    FOLLOW_SUPER_in_includeExpr1986 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_SUPER_in_includeExpr1986_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_includeExpr1988 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_includeExpr1988_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr1990 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr1990_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr1992 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr1992_data Count:(NSUInteger)1] retain];
    FOLLOW_args_in_includeExpr1994 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_args_in_includeExpr1994_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr1996 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr1996_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr2029 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2029_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr2031 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2031_data Count:(NSUInteger)1] retain];
    FOLLOW_args_in_includeExpr2033 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_args_in_includeExpr2033_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr2035 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2035_data Count:(NSUInteger)1] retain];
    FOLLOW_AT_in_includeExpr2080 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_AT_in_includeExpr2080_data Count:(NSUInteger)1] retain];
    FOLLOW_SUPER_in_includeExpr2082 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_SUPER_in_includeExpr2082_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_includeExpr2084 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_includeExpr2084_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr2086 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2086_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr2088 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2088_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr2092 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2092_data Count:(NSUInteger)1] retain];
    FOLLOW_AT_in_includeExpr2120 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_AT_in_includeExpr2120_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr2122 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2122_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr2124 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2124_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr2128 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2128_data Count:(NSUInteger)1] retain];
    FOLLOW_primary_in_includeExpr2168 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_primary_in_includeExpr2168_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_primary2187 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_primary2187_data Count:(NSUInteger)1] retain];
    FOLLOW_STRING_in_primary2197 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_STRING_in_primary2197_data Count:(NSUInteger)1] retain];
    FOLLOW_subtemplate_in_primary2207 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_subtemplate_in_primary2207_data Count:(NSUInteger)1] retain];
    FOLLOW_list_in_primary2217 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_list_in_primary2217_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_primary2229 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_primary2229_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_primary2231 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_primary2231_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_primary2233 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_primary2233_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_primary2247 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_primary2247_data Count:(NSUInteger)1] retain];
    FOLLOW_argExprList_in_primary2249 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_argExprList_in_primary2249_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_primary2252 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_primary2252_data Count:(NSUInteger)1] retain];
    FOLLOW_argExprList_in_args2360 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_argExprList_in_args2360_data Count:(NSUInteger)1] retain];
    FOLLOW_namedArg_in_args2370 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_namedArg_in_args2370_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_args2374 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_args2374_data Count:(NSUInteger)1] retain];
    FOLLOW_namedArg_in_args2376 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_namedArg_in_args2376_data Count:(NSUInteger)1] retain];
    FOLLOW_arg_in_argExprList2403 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_arg_in_argExprList2403_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_argExprList2407 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_argExprList2407_data Count:(NSUInteger)1] retain];
    FOLLOW_arg_in_argExprList2409 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_arg_in_argExprList2409_data Count:(NSUInteger)1] retain];
    FOLLOW_exprNoComma_in_arg2426 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_exprNoComma_in_arg2426_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_namedArg2435 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_namedArg2435_data Count:(NSUInteger)1] retain];
    FOLLOW_EQUALS_in_namedArg2437 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_EQUALS_in_namedArg2437_data Count:(NSUInteger)1] retain];
    FOLLOW_arg_in_namedArg2439 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_arg_in_namedArg2439_data Count:(NSUInteger)1] retain];
    FOLLOW_LBRACK_in_list2472 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LBRACK_in_list2472_data Count:(NSUInteger)1] retain];
    FOLLOW_RBRACK_in_list2474 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RBRACK_in_list2474_data Count:(NSUInteger)1] retain];
    FOLLOW_LBRACK_in_list2491 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_LBRACK_in_list2491_data Count:(NSUInteger)1] retain];
    FOLLOW_listElement_in_list2493 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_listElement_in_list2493_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_list2497 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_list2497_data Count:(NSUInteger)1] retain];
    FOLLOW_listElement_in_list2499 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_listElement_in_list2499_data Count:(NSUInteger)1] retain];
    FOLLOW_RBRACK_in_list2504 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_RBRACK_in_list2504_data Count:(NSUInteger)1] retain];
    FOLLOW_exprNoComma_in_listElement2527 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_exprNoComma_in_listElement2527_data Count:(NSUInteger)1] retain];

    [ANTLRBaseRecognizer setTokenNames:[[NSArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>", 
 @"IF", @"ELSE", @"ELSEIF", @"ENDIF", @"SUPER", @"SEMI", @"BANG", @"ELLIPSIS", 
 @"EQUALS", @"COLON", @"LPAREN", @"RPAREN", @"LBRACK", @"RBRACK", @"COMMA", 
 @"DOT", @"LCURLY", @"RCURLY", @"TEXT", @"LDELIM", @"RDELIM", @"ID", @"STRING", 
 @"WS", @"PIPE", @"OR", @"AND", @"INDENT", @"NEWLINE", @"AT", @"REGION_END", 
 @"EXPR", @"OPTIONS", @"PROP", @"PROP_IND", @"INCLUDE", @"INCLUDE_IND", 
 @"EXEC_FUNC", @"INCLUDE_SUPER", @"INCLUDE_SUPER_REGION", @"INCLUDE_REGION", 
 @"TO_STR", @"LIST", @"MAP", @"ZIP", @"SUBTEMPLATE", @"ARGS", @"ELEMENTS", 
 @"REGION", @"A_NULL", nil] retain]];
    [ANTLRBaseRecognizer setGrammarFileName:@"/Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g"];
}

+ (STParser *)newSTParser:(id<ANTLRTokenStream>)aStream
{
    return [[STParser alloc] initWithTokenStream:aStream];

}

- (id) initWithTokenStream:(id<ANTLRTokenStream>)aStream
{
    if ((self = [super initWithTokenStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:27+1] retain]]) != nil) {


        dfa2 = [DFA2 newDFA2WithRecognizer:self];
        dfa28 = [DFA28 newDFA28WithRecognizer:self];
        /* start of actions-actionScope-init */
        /* start of init */
        /* AST genericParser.init */
        [self setTreeAdaptor:[[ANTLRCommonTreeAdaptor newTreeAdaptor] retain]];
    }
    return self;
}

- (void) dealloc
{
    [dfa2 release];
    [dfa28 release];
    /* AST genericParser.dealloc */
    [self setTreeAdaptor:nil];

    [super dealloc];
}

/* ObjC start members */
/* ObjC end members */
/* ObjC start actions.(actionScope).methods */

+ (id) newSTParser:(id<ANTLRTokenStream>)anInput error:(ErrorManager *)anErrMgr token:(ANTLRCommonToken *)aTemplateToken
{
    return [[STParser alloc] init:anInput error:anErrMgr token:aTemplateToken];
}

- (id) init:(id<ANTLRTokenStream>)anInput error:(ErrorManager *)anErrMgr token:(ANTLRCommonToken *)aTemplateToken
{
    if (self = [super initWithTokenStream:(id<ANTLRTokenStream>)anInput]) {
        errMgr = anErrMgr;
        templateToken = aTemplateToken;
    }
    return self;
}

- (id) recoverFromMismatchedToken:(id<ANTLRIntStream>)anInput type:(NSInteger)ttype follow:(ANTLRBitSet *)follow
{
    @throw [ANTLRMismatchedTokenException newANTLRMismatchedTokenException:ttype Stream:anInput];
}

/* ObjC end actions.(actionScope).methods */
/* ObjC start methods() */
/* AST genericParser.methods */
/* AST parserMethods */
- (id<ANTLRTreeAdaptor>) getTreeAdaptor
{
	return treeAdaptor;
}

- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor
{
	if (aTreeAdaptor != treeAdaptor) {
		treeAdaptor = aTreeAdaptor;
	}
}
/* ObjC end methods() */
/* ObjC start rules */

/*
 * $ANTLR start templateAndEOF
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:100:1: templateAndEOF : template EOF -> ( template )? ;
 */
- (STParser_templateAndEOF_return *) templateAndEOF
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_templateAndEOF_return * retval = [STParser_templateAndEOF_return newSTParser_templateAndEOF_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *EOF2 = nil;
        STParser_template_return * template1 = nil;


        ANTLRCommonTree *EOF2_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_EOF = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token EOF"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_template = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:100:16: ( template EOF -> ( template )? ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:100:18: template EOF // alt
        {
        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_templateAndEOF187];
        template1 = [self template];

        [self popFollow];


        [stream_template addElement:[template1 getTree]];
        EOF2=(ANTLRCommonToken *)[self match:input TokenType:EOF Follow:FOLLOW_EOF_in_templateAndEOF189];  
            [stream_EOF addElement:EOF2];



        // AST REWRITE
        // elements: template
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 100:31: -> ( template )?
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:100:34: ( template )?
            if ( [stream_template hasNext] ) {
            	[treeAdaptor addChild:[stream_template nextTree] toTree:root_0];

            }
            [stream_template reset];

        }

        retval.tree = root_0;

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_EOF release];
        [stream_template release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end templateAndEOF */

/*
 * $ANTLR start template
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:102:1: template : ( element )* ;
 */
- (STParser_template_return *) template
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_template_return * retval = [STParser_template_return newSTParser_template_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STParser_element_return * element3 = nil;



        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:102:10: ( ( element )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:102:12: ( element )* // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        do {
            NSInteger alt1=2;
            switch ([input LA:1]) { // dfaLoopbackStateSwitch
                case LDELIM: ;
                    {
                    NSInteger LA1_2 = [input LA:2];
                    if ( (LA1_2==IF||LA1_2==SUPER||LA1_2==LPAREN||LA1_2==LBRACK||LA1_2==LCURLY||(LA1_2>=ID && LA1_2<=STRING)||LA1_2==AT) ) {
                        alt1=1;
                    }


                    }
                    break;
                case INDENT: ;
                    {
                    NSInteger LA1_3 = [input LA:2];
                    if ( (LA1_3==LDELIM) ) {
                        NSInteger LA1_5 = [input LA:3];
                        if ( (LA1_5==IF||LA1_5==SUPER||LA1_5==LPAREN||LA1_5==LBRACK||LA1_5==LCURLY||(LA1_5>=ID && LA1_5<=STRING)||LA1_5==AT) ) {
                            alt1=1;
                        }


                    }
                    else if ( (LA1_3==TEXT||(LA1_3>=INDENT && LA1_3<=NEWLINE)) ) {
                        alt1=1;
                    }


                    }
                    break;
                case TEXT: ;
                case NEWLINE: ;
                    {
                    alt1=1;
                    }
                    break;

            }

            switch (alt1) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:102:12: element // alt
                    {
                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_element_in_template203];
                    element3 = [self element];

                    [self popFollow];


                    [treeAdaptor addChild:[element3 getTree] toTree:root_0];

                    }
                    break;

                default :
                    goto loop1;
            }
        } while (YES);
        loop1: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end template */

/*
 * $ANTLR start element
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:104:1: element : ( INDENT element -> ^( INDENT element ) | ifstat | exprTag | text | region | NEWLINE );
 */
- (STParser_element_return *) element
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_element_return * retval = [STParser_element_return newSTParser_element_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *INDENT4 = nil;
        ANTLRCommonToken *NEWLINE10 = nil;
        STParser_element_return * element5 = nil;

        STParser_ifstat_return * ifstat6 = nil;

        STParser_exprTag_return * exprTag7 = nil;

        STParser_text_return * text8 = nil;

        STParser_region_return * region9 = nil;


        ANTLRCommonTree *INDENT4_tree=nil;
        ANTLRCommonTree *NEWLINE10_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_INDENT = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_element = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule element"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:105:5: ( INDENT element -> ^( INDENT element ) | ifstat | exprTag | text | region | NEWLINE ) //ruleblock
        NSInteger alt2=6;
        alt2 = [dfa2 predict:input];
        switch (alt2) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:105:9: INDENT element // alt
                {
                INDENT4=(ANTLRCommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_element219];  
                    [stream_INDENT addElement:INDENT4];

                /* ruleRef */
                [self pushFollow:FOLLOW_element_in_element221];
                element5 = [self element];

                [self popFollow];


                [stream_element addElement:[element5 getTree]];


                // AST REWRITE
                // elements: element, INDENT
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 105:24: -> ^( INDENT element )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:105:27: ^( INDENT element )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [stream_INDENT nextNode] old:root_1];

                        [treeAdaptor addChild:[stream_element nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:106:9: ifstat // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_ifstat_in_element239];
                ifstat6 = [self ifstat];

                [self popFollow];


                [treeAdaptor addChild:[ifstat6 getTree] toTree:root_0];

                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:107:9: exprTag // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_exprTag_in_element249];
                exprTag7 = [self exprTag];

                [self popFollow];


                [treeAdaptor addChild:[exprTag7 getTree] toTree:root_0];

                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:108:9: text // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_text_in_element259];
                text8 = [self text];

                [self popFollow];


                [treeAdaptor addChild:[text8 getTree] toTree:root_0];

                }
                break;
            case 5 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:109:9: region // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_region_in_element269];
                region9 = [self region];

                [self popFollow];


                [treeAdaptor addChild:[region9 getTree] toTree:root_0];

                }
                break;
            case 6 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:110:9: NEWLINE // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser tokenRef */
                NEWLINE10=(ANTLRCommonToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_element279]; 
                NEWLINE10_tree = /* ASTParser createNodeFromToken */
                (ANTLRCommonTree *)[[treeAdaptor createTree:NEWLINE10] retain];
                [treeAdaptor addChild:NEWLINE10_tree  toTree:root_0];


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_INDENT release];
        [stream_element release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end element */

/*
 * $ANTLR start text
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:113:1: text : TEXT ;
 */
- (STParser_text_return *) text
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_text_return * retval = [STParser_text_return newSTParser_text_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *TEXT11 = nil;

        ANTLRCommonTree *TEXT11_tree=nil;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:113:6: ( TEXT ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:113:8: TEXT // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        /* ASTParser tokenRef */
        TEXT11=(ANTLRCommonToken *)[self match:input TokenType:TEXT Follow:FOLLOW_TEXT_in_text292]; 
        TEXT11_tree = /* ASTParser createNodeFromToken */
        (ANTLRCommonTree *)[[treeAdaptor createTree:TEXT11] retain];
        [treeAdaptor addChild:TEXT11_tree  toTree:root_0];


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end text */

/*
 * $ANTLR start exprTag
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:115:1: exprTag : LDELIM expr ( ';' exprOptions )? RDELIM -> ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? ) ;
 */
- (STParser_exprTag_return *) exprTag
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_exprTag_return * retval = [STParser_exprTag_return newSTParser_exprTag_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *LDELIM12 = nil;
        ANTLRCommonToken *char_literal14 = nil;
        ANTLRCommonToken *RDELIM16 = nil;
        STParser_expr_return * expr13 = nil;

        STParser_exprOptions_return * exprOptions15 = nil;


        ANTLRCommonTree *LDELIM12_tree=nil;
        ANTLRCommonTree *char_literal14_tree=nil;
        ANTLRCommonTree *RDELIM16_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_RDELIM = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RDELIM"] retain];
        ANTLRRewriteRuleTokenStream *stream_LDELIM = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LDELIM"] retain];
        ANTLRRewriteRuleTokenStream *stream_SEMI = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token SEMI"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_exprOptions = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule exprOptions"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_expr = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:116:5: ( LDELIM expr ( ';' exprOptions )? RDELIM -> ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:116:9: LDELIM expr ( ';' exprOptions )? RDELIM // alt
        {
        LDELIM12=(ANTLRCommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_exprTag307];  
            [stream_LDELIM addElement:LDELIM12];

        /* ruleRef */
        [self pushFollow:FOLLOW_expr_in_exprTag309];
        expr13 = [self expr];

        [self popFollow];


        [stream_expr addElement:[expr13 getTree]];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:116:21: ( ';' exprOptions )? // block
        NSInteger alt3=2;
        NSInteger LA3_0 = [input LA:1];

        if ( (LA3_0==SEMI) ) {
            alt3=1;
        }
        switch (alt3) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:116:23: ';' exprOptions // alt
                {
                char_literal14=(ANTLRCommonToken *)[self match:input TokenType:SEMI Follow:FOLLOW_SEMI_in_exprTag313];  
                    [stream_SEMI addElement:char_literal14];

                /* ruleRef */
                [self pushFollow:FOLLOW_exprOptions_in_exprTag315];
                exprOptions15 = [self exprOptions];

                [self popFollow];


                [stream_exprOptions addElement:[exprOptions15 getTree]];

                }
                break;

        }

        RDELIM16=(ANTLRCommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_exprTag320];  
            [stream_RDELIM addElement:RDELIM16];



        // AST REWRITE
        // elements: exprOptions, expr
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 117:9: -> ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:117:12: ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:EXPR FromToken:LDELIM12 Text:@"EXPR"]
                                                                       old:root_1];

                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:117:41: ( exprOptions )?
                if ( [stream_exprOptions hasNext] ) {
                	[treeAdaptor addChild:[stream_exprOptions nextTree] toTree:root_1];

                }
                [stream_exprOptions reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        retval.tree = root_0;

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_RDELIM release];
        [stream_LDELIM release];
        [stream_SEMI release];
        [stream_exprOptions release];
        [stream_expr release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end exprTag */

/*
 * $ANTLR start region
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:120:1: region : LDELIM '@' ID RDELIM template LDELIM '@end' RDELIM -> ^( REGION ID template ) ;
 */
- (STParser_region_return *) region
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_region_return * retval = [STParser_region_return newSTParser_region_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *LDELIM17 = nil;
        ANTLRCommonToken *char_literal18 = nil;
        ANTLRCommonToken *ID19 = nil;
        ANTLRCommonToken *RDELIM20 = nil;
        ANTLRCommonToken *LDELIM22 = nil;
        ANTLRCommonToken *string_literal23 = nil;
        ANTLRCommonToken *RDELIM24 = nil;
        STParser_template_return * template21 = nil;


        ANTLRCommonTree *LDELIM17_tree=nil;
        ANTLRCommonTree *char_literal18_tree=nil;
        ANTLRCommonTree *ID19_tree=nil;
        ANTLRCommonTree *RDELIM20_tree=nil;
        ANTLRCommonTree *LDELIM22_tree=nil;
        ANTLRCommonTree *string_literal23_tree=nil;
        ANTLRCommonTree *RDELIM24_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_AT = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token AT"] retain];
        ANTLRRewriteRuleTokenStream *stream_RDELIM = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RDELIM"] retain];
        ANTLRRewriteRuleTokenStream *stream_ID = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        ANTLRRewriteRuleTokenStream *stream_REGION_END = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token REGION_END"] retain];
        ANTLRRewriteRuleTokenStream *stream_LDELIM = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LDELIM"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_template = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:120:8: ( LDELIM '@' ID RDELIM template LDELIM '@end' RDELIM -> ^( REGION ID template ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:120:10: LDELIM '@' ID RDELIM template LDELIM '@end' RDELIM // alt
        {
        LDELIM17=(ANTLRCommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_region353];  
            [stream_LDELIM addElement:LDELIM17];

        char_literal18=(ANTLRCommonToken *)[self match:input TokenType:AT Follow:FOLLOW_AT_in_region355];  
            [stream_AT addElement:char_literal18];

        ID19=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_region357];  
            [stream_ID addElement:ID19];

        RDELIM20=(ANTLRCommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_region359];  
            [stream_RDELIM addElement:RDELIM20];

        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_region361];
        template21 = [self template];

        [self popFollow];


        [stream_template addElement:[template21 getTree]];
        LDELIM22=(ANTLRCommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_region363];  
            [stream_LDELIM addElement:LDELIM22];

        string_literal23=(ANTLRCommonToken *)[self match:input TokenType:REGION_END Follow:FOLLOW_REGION_END_in_region365];  
            [stream_REGION_END addElement:string_literal23];

        RDELIM24=(ANTLRCommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_region367];  
            [stream_RDELIM addElement:RDELIM24];



        // AST REWRITE
        // elements: ID, template
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 120:61: -> ^( REGION ID template )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:120:64: ^( REGION ID template )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:REGION Text:@"REGION"]
                                                                       old:root_1];

                 // TODO: args: 
                [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];
                [treeAdaptor addChild:[stream_template nextTree] toTree:root_1];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        retval.tree = root_0;

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_AT release];
        [stream_RDELIM release];
        [stream_ID release];
        [stream_REGION_END release];
        [stream_LDELIM release];
        [stream_template release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end region */

/*
 * $ANTLR start subtemplate
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:122:1: subtemplate : lc= '{' (ids+= ID ( ',' ids+= ID )* '|' )? template ( INDENT )? '}' -> ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* template ) ;
 */
- (STParser_subtemplate_return *) subtemplate
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_subtemplate_return * retval = [STParser_subtemplate_return newSTParser_subtemplate_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *lc = nil;
        ANTLRCommonToken *char_literal25 = nil;
        ANTLRCommonToken *char_literal26 = nil;
        ANTLRCommonToken *INDENT28 = nil;
        ANTLRCommonToken *char_literal29 = nil;
        ANTLRCommonToken *ids = nil;
        NSMutableArray *list_ids = nil;
        STParser_template_return * template27 = nil;


        ANTLRCommonTree *lc_tree=nil;
        ANTLRCommonTree *char_literal25_tree=nil;
        ANTLRCommonTree *char_literal26_tree=nil;
        ANTLRCommonTree *INDENT28_tree=nil;
        ANTLRCommonTree *char_literal29_tree=nil;
        ANTLRCommonTree *ids_tree = nil;
        ANTLRRewriteRuleTokenStream *stream_LCURLY = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LCURLY"] retain];
        ANTLRRewriteRuleTokenStream *stream_PIPE = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token PIPE"] retain];
        ANTLRRewriteRuleTokenStream *stream_ID = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        ANTLRRewriteRuleTokenStream *stream_COMMA = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        ANTLRRewriteRuleTokenStream *stream_INDENT = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"] retain];
        ANTLRRewriteRuleTokenStream *stream_RCURLY = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RCURLY"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_template = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:123:5: (lc= '{' (ids+= ID ( ',' ids+= ID )* '|' )? template ( INDENT )? '}' -> ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* template ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:123:9: lc= '{' (ids+= ID ( ',' ids+= ID )* '|' )? template ( INDENT )? '}' // alt
        {
        lc=(ANTLRCommonToken *)[self match:input TokenType:LCURLY Follow:FOLLOW_LCURLY_in_subtemplate394];  
            [stream_LCURLY addElement:lc];

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:123:16: (ids+= ID ( ',' ids+= ID )* '|' )? // block
        NSInteger alt5=2;
        NSInteger LA5_0 = [input LA:1];

        if ( (LA5_0==ID) ) {
            alt5=1;
        }
        switch (alt5) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:123:17: ids+= ID ( ',' ids+= ID )* '|' // alt
                {
                ids=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_subtemplate400];  
                    [stream_ID addElement:ids];

                if (list_ids == nil) list_ids = [[NSMutableArray arrayWithCapacity:5] retain];
                [list_ids addObject:ids];

                do {
                    NSInteger alt4=2;
                    NSInteger LA4_0 = [input LA:1];
                    if ( (LA4_0==COMMA) ) {
                        alt4=1;
                    }


                    switch (alt4) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:123:28: ',' ids+= ID // alt
                            {
                            char_literal25=(ANTLRCommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_subtemplate404];  
                                [stream_COMMA addElement:char_literal25];

                            ids=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_subtemplate409];  
                                [stream_ID addElement:ids];

                            if (list_ids == nil) list_ids = [[NSMutableArray arrayWithCapacity:5] retain];
                            [list_ids addObject:ids];


                            }
                            break;

                        default :
                            goto loop4;
                    }
                } while (YES);
                loop4: ;

                char_literal26=(ANTLRCommonToken *)[self match:input TokenType:PIPE Follow:FOLLOW_PIPE_in_subtemplate414];  
                    [stream_PIPE addElement:char_literal26];


                }
                break;

        }

        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_subtemplate419];
        template27 = [self template];

        [self popFollow];


        [stream_template addElement:[template27 getTree]];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:123:60: ( INDENT )? // block
        NSInteger alt6=2;
        NSInteger LA6_0 = [input LA:1];

        if ( (LA6_0==INDENT) ) {
            alt6=1;
        }
        switch (alt6) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:123:60: INDENT // alt
                {
                INDENT28=(ANTLRCommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_subtemplate421];  
                    [stream_INDENT addElement:INDENT28];


                }
                break;

        }

        char_literal29=(ANTLRCommonToken *)[self match:input TokenType:RCURLY Follow:FOLLOW_RCURLY_in_subtemplate424];  
            [stream_RCURLY addElement:char_literal29];



        // AST REWRITE
        // elements: ids, template
        // token labels: 
        // rule labels: retval
        // token list labels: ids
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleTokenStream *stream_ids =
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                description:@"token ids" elements:list_ids] retain];
        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 125:9: -> ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* template )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:125:12: ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* template )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:SUBTEMPLATE FromToken:lc Text:@"SUBTEMPLATE"]
                                                                       old:root_1];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:125:46: ( ^( ARGS $ids) )*
                while ( [stream_ids hasNext] ) {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:125:46: ^( ARGS $ids)
                    {
                        ANTLRCommonTree *root_2 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_2 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:ARGS Text:@"ARGS"]
                                                                               old:root_2];

                        [treeAdaptor addChild:[stream_ids nextNode] toTree:root_2];

                        [treeAdaptor addChild:root_2 toTree:root_1];
                    }

                }
                [stream_ids reset];
                [treeAdaptor addChild:[stream_template nextTree] toTree:root_1];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        retval.tree = root_0;

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [list_ids release];
        [retval setStop:[input LT:-1]];

        [stream_LCURLY release];
        [stream_PIPE release];
        [stream_ID release];
        [stream_COMMA release];
        [stream_INDENT release];
        [stream_RCURLY release];
        [stream_template release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end subtemplate */

/*
 * $ANTLR start ifstat
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:128:1: ifstat : LDELIM 'if' '(' c1= conditional ')' RDELIM t1= template ( ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template )* ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? ( INDENT )? endif= LDELIM 'endif' RDELIM ({...}? => NEWLINE )? -> ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ;
 */
- (STParser_ifstat_return *) ifstat
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_ifstat_return * retval = [STParser_ifstat_return newSTParser_ifstat_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *endif = nil;
        ANTLRCommonToken *LDELIM30 = nil;
        ANTLRCommonToken *string_literal31 = nil;
        ANTLRCommonToken *char_literal32 = nil;
        ANTLRCommonToken *char_literal33 = nil;
        ANTLRCommonToken *RDELIM34 = nil;
        ANTLRCommonToken *INDENT35 = nil;
        ANTLRCommonToken *LDELIM36 = nil;
        ANTLRCommonToken *string_literal37 = nil;
        ANTLRCommonToken *char_literal38 = nil;
        ANTLRCommonToken *char_literal39 = nil;
        ANTLRCommonToken *RDELIM40 = nil;
        ANTLRCommonToken *INDENT41 = nil;
        ANTLRCommonToken *LDELIM42 = nil;
        ANTLRCommonToken *string_literal43 = nil;
        ANTLRCommonToken *RDELIM44 = nil;
        ANTLRCommonToken *INDENT45 = nil;
        ANTLRCommonToken *string_literal46 = nil;
        ANTLRCommonToken *RDELIM47 = nil;
        ANTLRCommonToken *NEWLINE48 = nil;
        NSMutableArray *list_c2 = nil;
        NSMutableArray *list_t2 = nil;
        STParser_conditional_return * c1 = nil;

        STParser_template_return * t1 = nil;

        STParser_template_return * t3 = nil;

        ANTLRParserRuleReturnScope *c2 = nil;
        ANTLRParserRuleReturnScope *t2 = nil;
        ANTLRCommonTree *endif_tree=nil;
        ANTLRCommonTree *LDELIM30_tree=nil;
        ANTLRCommonTree *string_literal31_tree=nil;
        ANTLRCommonTree *char_literal32_tree=nil;
        ANTLRCommonTree *char_literal33_tree=nil;
        ANTLRCommonTree *RDELIM34_tree=nil;
        ANTLRCommonTree *INDENT35_tree=nil;
        ANTLRCommonTree *LDELIM36_tree=nil;
        ANTLRCommonTree *string_literal37_tree=nil;
        ANTLRCommonTree *char_literal38_tree=nil;
        ANTLRCommonTree *char_literal39_tree=nil;
        ANTLRCommonTree *RDELIM40_tree=nil;
        ANTLRCommonTree *INDENT41_tree=nil;
        ANTLRCommonTree *LDELIM42_tree=nil;
        ANTLRCommonTree *string_literal43_tree=nil;
        ANTLRCommonTree *RDELIM44_tree=nil;
        ANTLRCommonTree *INDENT45_tree=nil;
        ANTLRCommonTree *string_literal46_tree=nil;
        ANTLRCommonTree *RDELIM47_tree=nil;
        ANTLRCommonTree *NEWLINE48_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_ENDIF = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ENDIF"] retain];
        ANTLRRewriteRuleTokenStream *stream_RDELIM = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RDELIM"] retain];
        ANTLRRewriteRuleTokenStream *stream_RPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        ANTLRRewriteRuleTokenStream *stream_NEWLINE = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token NEWLINE"] retain];
        ANTLRRewriteRuleTokenStream *stream_LDELIM = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LDELIM"] retain];
        ANTLRRewriteRuleTokenStream *stream_INDENT = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"] retain];
        ANTLRRewriteRuleTokenStream *stream_LPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        ANTLRRewriteRuleTokenStream *stream_IF = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token IF"] retain];
        ANTLRRewriteRuleTokenStream *stream_ELSE = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ELSE"] retain];
        ANTLRRewriteRuleTokenStream *stream_ELSEIF = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ELSEIF"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_template = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_conditional = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule conditional"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:129:5: ( LDELIM 'if' '(' c1= conditional ')' RDELIM t1= template ( ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template )* ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? ( INDENT )? endif= LDELIM 'endif' RDELIM ({...}? => NEWLINE )? -> ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:129:9: LDELIM 'if' '(' c1= conditional ')' RDELIM t1= template ( ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template )* ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? ( INDENT )? endif= LDELIM 'endif' RDELIM ({...}? => NEWLINE )? // alt
        {
        LDELIM30=(ANTLRCommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat478];  
            [stream_LDELIM addElement:LDELIM30];

        string_literal31=(ANTLRCommonToken *)[self match:input TokenType:IF Follow:FOLLOW_IF_in_ifstat480];  
            [stream_IF addElement:string_literal31];

        char_literal32=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_ifstat482];  
            [stream_LPAREN addElement:char_literal32];

        /* ruleRef */
        [self pushFollow:FOLLOW_conditional_in_ifstat486];
        c1 = [self conditional];

        [self popFollow];


        [stream_conditional addElement:[c1 getTree]];
        char_literal33=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_ifstat488];  
            [stream_RPAREN addElement:char_literal33];

        RDELIM34=(ANTLRCommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat490];  
            [stream_RDELIM addElement:RDELIM34];

        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_ifstat506];
        t1 = [self template];

        [self popFollow];


        [stream_template addElement:[t1 getTree]];
        do {
            NSInteger alt8=2;
            NSInteger LA8_0 = [input LA:1];
            if ( (LA8_0==INDENT) ) {
                NSInteger LA8_1 = [input LA:2];
                if ( (LA8_1==LDELIM) ) {
                    NSInteger LA8_2 = [input LA:3];
                    if ( (LA8_2==ELSEIF) ) {
                        alt8=1;
                    }


                }


            }
            else if ( (LA8_0==LDELIM) ) {
                NSInteger LA8_2 = [input LA:2];
                if ( (LA8_2==ELSEIF) ) {
                    alt8=1;
                }


            }


            switch (alt8) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:131:15: ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template // alt
                    {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:131:15: ( INDENT )? // block
                    NSInteger alt7=2;
                    NSInteger LA7_0 = [input LA:1];

                    if ( (LA7_0==INDENT) ) {
                        alt7=1;
                    }
                    switch (alt7) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:131:15: INDENT // alt
                            {
                            INDENT35=(ANTLRCommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat522];  
                                [stream_INDENT addElement:INDENT35];


                            }
                            break;

                    }

                    LDELIM36=(ANTLRCommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat525];  
                        [stream_LDELIM addElement:LDELIM36];

                    string_literal37=(ANTLRCommonToken *)[self match:input TokenType:ELSEIF Follow:FOLLOW_ELSEIF_in_ifstat527];  
                        [stream_ELSEIF addElement:string_literal37];

                    char_literal38=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_ifstat529];  
                        [stream_LPAREN addElement:char_literal38];

                    /* ruleRef */
                    [self pushFollow:FOLLOW_conditional_in_ifstat533];
                    c2 = [self conditional];

                    [self popFollow];


                    [stream_conditional addElement:[c2 getTree]];
                    if (list_c2 == nil) list_c2 = [[NSMutableArray arrayWithCapacity:5] retain];
                    [list_c2 addObject:[c2 getTree]];

                    char_literal39=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_ifstat535];  
                        [stream_RPAREN addElement:char_literal39];

                    RDELIM40=(ANTLRCommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat537];  
                        [stream_RDELIM addElement:RDELIM40];

                    /* ruleRef */
                    [self pushFollow:FOLLOW_template_in_ifstat541];
                    t2 = [self template];

                    [self popFollow];


                    [stream_template addElement:[t2 getTree]];
                    if (list_t2 == nil) list_t2 = [[NSMutableArray arrayWithCapacity:5] retain];
                    [list_t2 addObject:[t2 getTree]];


                    }
                    break;

                default :
                    goto loop8;
            }
        } while (YES);
        loop8: ;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:132:13: ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? // block
        NSInteger alt10=2;
        NSInteger LA10_0 = [input LA:1];

        if ( (LA10_0==INDENT) ) {
            NSInteger LA10_1 = [input LA:2];

            if ( (LA10_1==LDELIM) ) {
                NSInteger LA10_2 = [input LA:3];

                if ( (LA10_2==ELSE) ) {
                    alt10=1;
                }
            }
        }
        else if ( (LA10_0==LDELIM) ) {
            NSInteger LA10_2 = [input LA:2];

            if ( (LA10_2==ELSE) ) {
                alt10=1;
            }
        }
        switch (alt10) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:132:15: ( INDENT )? LDELIM 'else' RDELIM t3= template // alt
                {
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:132:15: ( INDENT )? // block
                NSInteger alt9=2;
                NSInteger LA9_0 = [input LA:1];

                if ( (LA9_0==INDENT) ) {
                    alt9=1;
                }
                switch (alt9) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:132:15: INDENT // alt
                        {
                        INDENT41=(ANTLRCommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat560];  
                            [stream_INDENT addElement:INDENT41];


                        }
                        break;

                }

                LDELIM42=(ANTLRCommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat563];  
                    [stream_LDELIM addElement:LDELIM42];

                string_literal43=(ANTLRCommonToken *)[self match:input TokenType:ELSE Follow:FOLLOW_ELSE_in_ifstat565];  
                    [stream_ELSE addElement:string_literal43];

                RDELIM44=(ANTLRCommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat567];  
                    [stream_RDELIM addElement:RDELIM44];

                /* ruleRef */
                [self pushFollow:FOLLOW_template_in_ifstat571];
                t3 = [self template];

                [self popFollow];


                [stream_template addElement:[t3 getTree]];

                }
                break;

        }

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:133:13: ( INDENT )? // block
        NSInteger alt11=2;
        NSInteger LA11_0 = [input LA:1];

        if ( (LA11_0==INDENT) ) {
            alt11=1;
        }
        switch (alt11) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:133:13: INDENT // alt
                {
                INDENT45=(ANTLRCommonToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat588];  
                    [stream_INDENT addElement:INDENT45];


                }
                break;

        }

        endif=(ANTLRCommonToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat594];  
            [stream_LDELIM addElement:endif];

        string_literal46=(ANTLRCommonToken *)[self match:input TokenType:ENDIF Follow:FOLLOW_ENDIF_in_ifstat596];  
            [stream_ENDIF addElement:string_literal46];

        RDELIM47=(ANTLRCommonToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat606];  
            [stream_RDELIM addElement:RDELIM47];

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:136:9: ({...}? => NEWLINE )? // block
        NSInteger alt12=2;
        NSInteger LA12_0 = [input LA:1];

        if ( (LA12_0==NEWLINE) ) {
            NSInteger LA12_1 = [input LA:2];

            if ( (( [((ANTLRCommonToken *)retval.start) getLine] != [[input LT:1] getLine] )) ) {
                alt12=1;
            }
        }
        switch (alt12) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:136:10: {...}? => NEWLINE // alt
                {
                if ( !(( [((ANTLRCommonToken *)retval.start) getLine] != [[input LT:1] getLine] )) ) {
                    @throw [ANTLRFailedPredicateException exceptionWithRuleName:@"ifstat" predicate:@" [$ifstat.start getLine] != [[input LT:1] getLine] " stream:input];
                }
                NEWLINE48=(ANTLRCommonToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_ifstat629];  
                    [stream_NEWLINE addElement:NEWLINE48];


                }
                break;

        }



        // AST REWRITE
        // elements: ELSE, c1, ELSEIF, t1, IF, t3, t2, c2
        // token labels: 
        // rule labels: t3, retval, t1, c1
        // token list labels: 
        // rule list labels: t2, c2
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_t3 =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token t3" element:t3!=nil?[t3 getTree]:nil] retain];
        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];
        ANTLRRewriteRuleSubtreeStream *stream_t1 =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token t1" element:t1!=nil?[t1 getTree]:nil] retain];
        ANTLRRewriteRuleSubtreeStream *stream_c1 =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token c1" element:c1!=nil?[c1 getTree]:nil] retain];
        ANTLRRewriteRuleSubtreeStream *stream_t2 =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token t2" elements:list_t2] retain];
        ANTLRRewriteRuleSubtreeStream *stream_c2 =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token c2" elements:list_c2] retain];
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 137:9: -> ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:137:12: ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [stream_IF nextNode] old:root_1];

                [treeAdaptor addChild:[stream_c1 nextTree] toTree:root_1];
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:137:23: ( $t1)?
                if ( [stream_t1 hasNext] ) {
                	[treeAdaptor addChild:[stream_t1 nextTree] toTree:root_1];

                }
                [stream_t1 reset];
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:137:28: ( ^( 'elseif' $c2 $t2) )*
                while ( [stream_ELSEIF hasNext]||[stream_t2 hasNext]||[stream_c2 hasNext] ) {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:137:28: ^( 'elseif' $c2 $t2)
                    {
                        ANTLRCommonTree *root_2 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_2 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [stream_ELSEIF nextNode] old:root_2];

                        [treeAdaptor addChild:[stream_c2 nextTree] toTree:root_2];
                        [treeAdaptor addChild:[stream_t2 nextTree] toTree:root_2];

                        [treeAdaptor addChild:root_2 toTree:root_1];
                    }

                }
                [stream_ELSEIF reset];
                [stream_t2 reset];
                [stream_c2 reset];
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:137:49: ( ^( 'else' ( $t3)? ) )?
                if ( [stream_ELSE hasNext]||[stream_t3 hasNext] ) {
                	// /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:137:49: ^( 'else' ( $t3)? )
                	{
                	    ANTLRCommonTree *root_2 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                	    root_2 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [stream_ELSE nextNode] old:root_2];

                	    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:137:58: ( $t3)?
                	    if ( [stream_t3 hasNext] ) {
                	    	[treeAdaptor addChild:[stream_t3 nextTree] toTree:root_2];

                	    }
                	    [stream_t3 reset];

                	    [treeAdaptor addChild:root_2 toTree:root_1];
                	}

                }
                [stream_ELSE reset];
                [stream_t3 reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        retval.tree = root_0;

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [list_c2 release];
        [list_t2 release];
        [retval setStop:[input LT:-1]];

        [stream_ENDIF release];
        [stream_RDELIM release];
        [stream_RPAREN release];
        [stream_NEWLINE release];
        [stream_LDELIM release];
        [stream_INDENT release];
        [stream_LPAREN release];
        [stream_IF release];
        [stream_ELSE release];
        [stream_ELSEIF release];
        [stream_template release];
        [stream_conditional release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end ifstat */

/*
 * $ANTLR start conditional
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:140:1: conditional : andConditional ( '||' andConditional )* ;
 */
- (STParser_conditional_return *) conditional
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_conditional_return * retval = [STParser_conditional_return newSTParser_conditional_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *string_literal50 = nil;
        STParser_andConditional_return * andConditional49 = nil;

        STParser_andConditional_return * andConditional51 = nil;


        ANTLRCommonTree *string_literal50_tree=nil;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:140:13: ( andConditional ( '||' andConditional )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:140:15: andConditional ( '||' andConditional )* // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_andConditional_in_conditional685];
        andConditional49 = [self andConditional];

        [self popFollow];


        [treeAdaptor addChild:[andConditional49 getTree] toTree:root_0];
        do {
            NSInteger alt13=2;
            NSInteger LA13_0 = [input LA:1];
            if ( (LA13_0==OR) ) {
                alt13=1;
            }


            switch (alt13) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:140:32: '||' andConditional // alt
                    {
                    string_literal50=(ANTLRCommonToken *)[self match:input TokenType:OR Follow:FOLLOW_OR_in_conditional689]; 
                    string_literal50_tree = /* ASTParser createNodeFromToken */
                    (ANTLRCommonTree *)[[treeAdaptor createTree:string_literal50] retain];
                    root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:string_literal50_tree old:root_0];

                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_andConditional_in_conditional692];
                    andConditional51 = [self andConditional];

                    [self popFollow];


                    [treeAdaptor addChild:[andConditional51 getTree] toTree:root_0];

                    }
                    break;

                default :
                    goto loop13;
            }
        } while (YES);
        loop13: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end conditional */

/*
 * $ANTLR start andConditional
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:142:1: andConditional : notConditional ( '&&' notConditional )* ;
 */
- (STParser_andConditional_return *) andConditional
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_andConditional_return * retval = [STParser_andConditional_return newSTParser_andConditional_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *string_literal53 = nil;
        STParser_notConditional_return * notConditional52 = nil;

        STParser_notConditional_return * notConditional54 = nil;


        ANTLRCommonTree *string_literal53_tree=nil;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:142:16: ( notConditional ( '&&' notConditional )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:142:18: notConditional ( '&&' notConditional )* // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_notConditional_in_andConditional704];
        notConditional52 = [self notConditional];

        [self popFollow];


        [treeAdaptor addChild:[notConditional52 getTree] toTree:root_0];
        do {
            NSInteger alt14=2;
            NSInteger LA14_0 = [input LA:1];
            if ( (LA14_0==AND) ) {
                alt14=1;
            }


            switch (alt14) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:142:35: '&&' notConditional // alt
                    {
                    string_literal53=(ANTLRCommonToken *)[self match:input TokenType:AND Follow:FOLLOW_AND_in_andConditional708]; 
                    string_literal53_tree = /* ASTParser createNodeFromToken */
                    (ANTLRCommonTree *)[[treeAdaptor createTree:string_literal53] retain];
                    root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:string_literal53_tree old:root_0];

                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_notConditional_in_andConditional711];
                    notConditional54 = [self notConditional];

                    [self popFollow];


                    [treeAdaptor addChild:[notConditional54 getTree] toTree:root_0];

                    }
                    break;

                default :
                    goto loop14;
            }
        } while (YES);
        loop14: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end andConditional */

/*
 * $ANTLR start notConditional
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:144:1: notConditional : ( '!' notConditionalExpr | '!' '(' conditional ')' | memberExpr ) ;
 */
- (STParser_notConditional_return *) notConditional
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_notConditional_return * retval = [STParser_notConditional_return newSTParser_notConditional_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *char_literal55 = nil;
        ANTLRCommonToken *char_literal57 = nil;
        ANTLRCommonToken *char_literal58 = nil;
        ANTLRCommonToken *char_literal60 = nil;
        STParser_notConditionalExpr_return * notConditionalExpr56 = nil;

        STParser_conditional_return * conditional59 = nil;

        STParser_memberExpr_return * memberExpr61 = nil;


        ANTLRCommonTree *char_literal55_tree=nil;
        ANTLRCommonTree *char_literal57_tree=nil;
        ANTLRCommonTree *char_literal58_tree=nil;
        ANTLRCommonTree *char_literal60_tree=nil;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:144:16: ( ( '!' notConditionalExpr | '!' '(' conditional ')' | memberExpr ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:144:18: ( '!' notConditionalExpr | '!' '(' conditional ')' | memberExpr ) // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:144:18: ( '!' notConditionalExpr | '!' '(' conditional ')' | memberExpr ) // block
        NSInteger alt15=3;
        NSInteger LA15_0 = [input LA:1];

        if ( (LA15_0==BANG) ) {
            NSInteger LA15_1 = [input LA:2];

            if ( (LA15_1==LPAREN) ) {
                alt15=2;
            }
            else if ( (LA15_1==ID) ) {
                alt15=1;
            }
            else {
                ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:15 state:1 stream:input];
                @throw nvae;
            }
        }
        else if ( (LA15_0==SUPER||LA15_0==LPAREN||LA15_0==LBRACK||LA15_0==LCURLY||(LA15_0>=ID && LA15_0<=STRING)||LA15_0==AT) ) {
            alt15=3;
        }
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:15 state:0 stream:input];
            @throw nvae;
        }
        switch (alt15) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:144:20: '!' notConditionalExpr // alt
                {
                char_literal55=(ANTLRCommonToken *)[self match:input TokenType:BANG Follow:FOLLOW_BANG_in_notConditional725]; 
                char_literal55_tree = /* ASTParser createNodeFromToken */
                (ANTLRCommonTree *)[[treeAdaptor createTree:char_literal55] retain];
                root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:char_literal55_tree old:root_0];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_notConditionalExpr_in_notConditional728];
                notConditionalExpr56 = [self notConditionalExpr];

                [self popFollow];


                [treeAdaptor addChild:[notConditionalExpr56 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:144:46: '!' '(' conditional ')' // alt
                {
                char_literal57=(ANTLRCommonToken *)[self match:input TokenType:BANG Follow:FOLLOW_BANG_in_notConditional732]; 
                char_literal57_tree = /* ASTParser createNodeFromToken */
                (ANTLRCommonTree *)[[treeAdaptor createTree:char_literal57] retain];
                root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:char_literal57_tree old:root_0];

                char_literal58=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_notConditional735]; 
                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_conditional_in_notConditional738];
                conditional59 = [self conditional];

                [self popFollow];


                [treeAdaptor addChild:[conditional59 getTree] toTree:root_0];
                char_literal60=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_notConditional740]; 

                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:144:75: memberExpr // alt
                {
                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_memberExpr_in_notConditional745];
                memberExpr61 = [self memberExpr];

                [self popFollow];


                [treeAdaptor addChild:[memberExpr61 getTree] toTree:root_0];

                }
                break;

        }


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end notConditional */

/*
 * $ANTLR start notConditionalExpr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:146:1: notConditionalExpr : ( ID -> ID ) (p= '.' prop= ID -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop) | p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr ) )* ;
 */
- (STParser_notConditionalExpr_return *) notConditionalExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_notConditionalExpr_return * retval = [STParser_notConditionalExpr_return newSTParser_notConditionalExpr_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *p = nil;
        ANTLRCommonToken *prop = nil;
        ANTLRCommonToken *ID62 = nil;
        ANTLRCommonToken *char_literal63 = nil;
        ANTLRCommonToken *char_literal65 = nil;
        STParser_mapExpr_return * mapExpr64 = nil;


        ANTLRCommonTree *p_tree=nil;
        ANTLRCommonTree *prop_tree=nil;
        ANTLRCommonTree *ID62_tree=nil;
        ANTLRCommonTree *char_literal63_tree=nil;
        ANTLRCommonTree *char_literal65_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_RPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        ANTLRRewriteRuleTokenStream *stream_DOT = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token DOT"] retain];
        ANTLRRewriteRuleTokenStream *stream_ID = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        ANTLRRewriteRuleTokenStream *stream_LPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_mapExpr = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapExpr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:147:5: ( ( ID -> ID ) (p= '.' prop= ID -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop) | p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr ) )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:147:9: ( ID -> ID ) (p= '.' prop= ID -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop) | p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr ) )* // alt
        {
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:147:9: ( ID -> ID ) // blockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:147:10: ID // alt
        {
        ID62=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_notConditionalExpr762];  
            [stream_ID addElement:ID62];



        // AST REWRITE
        // elements: ID
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 147:12: -> ID
        {
             // TODO: args: 
            [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_0];

        }

        retval.tree = root_0;

        }

        do {
            NSInteger alt16=3;
            NSInteger LA16_0 = [input LA:1];
            if ( (LA16_0==DOT) ) {
                NSInteger LA16_2 = [input LA:2];
                if ( (LA16_2==ID) ) {
                    alt16=1;
                }
                else if ( (LA16_2==LPAREN) ) {
                    alt16=2;
                }


            }


            switch (alt16) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:148:13: p= '.' prop= ID // alt
                    {
                    p=(ANTLRCommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_notConditionalExpr781];  
                        [stream_DOT addElement:p];

                    prop=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_notConditionalExpr785];  
                        [stream_ID addElement:prop];



                    // AST REWRITE
                    // elements: prop, notConditionalExpr
                    // token labels: prop
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    ANTLRRewriteRuleTokenStream *stream_prop = 
                        [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor description:@"token prop" element:prop] retain];
                    ANTLRRewriteRuleSubtreeStream *stream_retval =
                        [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                    root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 148:49: -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop)
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:148:52: ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop)
                        {
                            ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:PROP FromToken:p Text:@"PROP"]
                                                                                   old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];
                            [treeAdaptor addChild:[stream_prop nextNode] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }

                    retval.tree = root_0;

                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:149:13: p= '.' '(' mapExpr ')' // alt
                    {
                    p=(ANTLRCommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_notConditionalExpr836];  
                        [stream_DOT addElement:p];

                    char_literal63=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_notConditionalExpr838];  
                        [stream_LPAREN addElement:char_literal63];

                    /* ruleRef */
                    [self pushFollow:FOLLOW_mapExpr_in_notConditionalExpr840];
                    mapExpr64 = [self mapExpr];

                    [self popFollow];


                    [stream_mapExpr addElement:[mapExpr64 getTree]];
                    char_literal65=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_notConditionalExpr842];  
                        [stream_RPAREN addElement:char_literal65];



                    // AST REWRITE
                    // elements: mapExpr, notConditionalExpr
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    ANTLRRewriteRuleSubtreeStream *stream_retval =
                        [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                    root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 149:49: -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr )
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:149:52: ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr )
                        {
                            ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:PROP_IND FromToken:p Text:@"PROP_IND"]
                                                                                   old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];
                            [treeAdaptor addChild:[stream_mapExpr nextTree] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }

                    retval.tree = root_0;

                    }
                    break;

                default :
                    goto loop16;
            }
        } while (YES);
        loop16: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_RPAREN release];
        [stream_DOT release];
        [stream_ID release];
        [stream_LPAREN release];
        [stream_mapExpr release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end notConditionalExpr */

/*
 * $ANTLR start exprOptions
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:1: exprOptions : option ( ',' option )* -> ^( OPTIONS ( option )* ) ;
 */
- (STParser_exprOptions_return *) exprOptions
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_exprOptions_return * retval = [STParser_exprOptions_return newSTParser_exprOptions_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *char_literal67 = nil;
        STParser_option_return * option66 = nil;

        STParser_option_return * option68 = nil;


        ANTLRCommonTree *char_literal67_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_COMMA = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_option = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule option"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:13: ( option ( ',' option )* -> ^( OPTIONS ( option )* ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:15: option ( ',' option )* // alt
        {
        /* ruleRef */
        [self pushFollow:FOLLOW_option_in_exprOptions892];
        option66 = [self option];

        [self popFollow];


        [stream_option addElement:[option66 getTree]];
        do {
            NSInteger alt17=2;
            NSInteger LA17_0 = [input LA:1];
            if ( (LA17_0==COMMA) ) {
                alt17=1;
            }


            switch (alt17) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:24: ',' option // alt
                    {
                    char_literal67=(ANTLRCommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_exprOptions896];  
                        [stream_COMMA addElement:char_literal67];

                    /* ruleRef */
                    [self pushFollow:FOLLOW_option_in_exprOptions898];
                    option68 = [self option];

                    [self popFollow];


                    [stream_option addElement:[option68 getTree]];

                    }
                    break;

                default :
                    goto loop17;
            }
        } while (YES);
        loop17: ;



        // AST REWRITE
        // elements: option
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 153:38: -> ^( OPTIONS ( option )* )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:41: ^( OPTIONS ( option )* )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:OPTIONS Text:@"OPTIONS"]
                                                                       old:root_1];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:51: ( option )*
                while ( [stream_option hasNext] ) {
                    [treeAdaptor addChild:[stream_option nextTree] toTree:root_1];

                }
                [stream_option reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        retval.tree = root_0;

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_COMMA release];
        [stream_option release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end exprOptions */

/*
 * $ANTLR start option
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:155:1: option : ID ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) -> | -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] ) ->) ;
 */
- (STParser_option_return *) option
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_option_return * retval = [STParser_option_return newSTParser_option_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;


        NSString *IDstr = [[input LT:1] getText];
        NSString *defVal = [[Compiler defaultOptionValues] objectForKey:IDstr];
        BOOL validOption = ([[Compiler supportedOptions] objectForKey:IDstr] != nil);

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *ID69 = nil;
        ANTLRCommonToken *char_literal70 = nil;
        STParser_exprNoComma_return * exprNoComma71 = nil;


        ANTLRCommonTree *ID69_tree=nil;
        ANTLRCommonTree *char_literal70_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_EQUALS = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token EQUALS"] retain];
        ANTLRRewriteRuleTokenStream *stream_ID = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_exprNoComma = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule exprNoComma"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:161:5: ( ID ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) -> | -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] ) ->) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:161:9: ID ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) -> | -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] ) ->) // alt
        {
        ID69=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_option930];  
            [stream_ID addElement:ID69];


                if ( !validOption ) {
                    [errMgr compileTimeError:NO_SUCH_OPTION templateToken:templateToken t:ID69 arg:(ID69!=nil?[ID69 getText]:@"nil")];
                }
                
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:167:9: ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) -> | -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] ) ->) // block
        NSInteger alt18=2;
        NSInteger LA18_0 = [input LA:1];

        if ( (LA18_0==EQUALS) ) {
            alt18=1;
        }
        else if ( (LA18_0==COMMA||LA18_0==RDELIM) ) {
            alt18=2;
        }
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:18 state:0 stream:input];
            @throw nvae;
        }
        switch (alt18) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:167:13: '=' exprNoComma // alt
                {
                char_literal70=(ANTLRCommonToken *)[self match:input TokenType:EQUALS Follow:FOLLOW_EQUALS_in_option954];  
                    [stream_EQUALS addElement:char_literal70];

                /* ruleRef */
                [self pushFollow:FOLLOW_exprNoComma_in_option956];
                exprNoComma71 = [self exprNoComma];

                [self popFollow];


                [stream_exprNoComma addElement:[exprNoComma71 getTree]];


                // AST REWRITE
                // elements: ID, EQUALS, exprNoComma
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 167:49: -> {validOption}? ^( '=' ID exprNoComma )
                if (validOption) {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:167:67: ^( '=' ID exprNoComma )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [stream_EQUALS nextNode] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];
                        [treeAdaptor addChild:[stream_exprNoComma nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }
                else // 168:49: ->
                {
                    root_0 = nil;
                }

                retval.tree = root_0;

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:169:13:  // alt
                {

                            if ( defVal==nil ) {
                                [errMgr compileTimeError:NO_DEFAULT_VALUE templateToken:templateToken t:ID69  arg:(ID69!=nil?[ID69 getText]:@"nil")];
                            }
                            


                // AST REWRITE
                // elements: ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 174:49: -> {validOption&&defVal!=nil}? ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] )
                if (validOption&&defVal!=nil) {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:175:52: ^( EQUALS[@\"=\"] ID STRING[$ID, defVal] )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:EQUALS FromToken:@"=" Text:@"EQUALS"]
                                                                               old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];
                        [treeAdaptor addChild:        [treeAdaptor createTree:STRING FromToken:ID69 Text:defVal] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }
                else // 176:49: ->
                {
                    root_0 = nil;
                }

                retval.tree = root_0;

                }
                break;

        }


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_EQUALS release];
        [stream_ID release];
        [stream_exprNoComma release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end option */

/*
 * $ANTLR start exprNoComma
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:180:1: exprNoComma : memberExpr ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) ;
 */
- (STParser_exprNoComma_return *) exprNoComma
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_exprNoComma_return * retval = [STParser_exprNoComma_return newSTParser_exprNoComma_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *char_literal73 = nil;
        STParser_memberExpr_return * memberExpr72 = nil;

        STParser_mapTemplateRef_return * mapTemplateRef74 = nil;


        ANTLRCommonTree *char_literal73_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_COLON = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COLON"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_memberExpr = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule memberExpr"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_mapTemplateRef = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapTemplateRef"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:181:5: ( memberExpr ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:181:9: memberExpr ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) // alt
        {
        /* ruleRef */
        [self pushFollow:FOLLOW_memberExpr_in_exprNoComma1244];
        memberExpr72 = [self memberExpr];

        [self popFollow];


        [stream_memberExpr addElement:[memberExpr72 getTree]];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:182:9: ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) // block
        NSInteger alt19=2;
        NSInteger LA19_0 = [input LA:1];

        if ( (LA19_0==COLON) ) {
            alt19=1;
        }
        else if ( (LA19_0==RPAREN||(LA19_0>=RBRACK && LA19_0<=COMMA)||LA19_0==RDELIM) ) {
            alt19=2;
        }
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:19 state:0 stream:input];
            @throw nvae;
        }
        switch (alt19) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:182:11: ':' mapTemplateRef // alt
                {
                char_literal73=(ANTLRCommonToken *)[self match:input TokenType:COLON Follow:FOLLOW_COLON_in_exprNoComma1256];  
                    [stream_COLON addElement:char_literal73];

                /* ruleRef */
                [self pushFollow:FOLLOW_mapTemplateRef_in_exprNoComma1258];
                mapTemplateRef74 = [self mapTemplateRef];

                [self popFollow];


                [stream_mapTemplateRef addElement:[mapTemplateRef74 getTree]];


                // AST REWRITE
                // elements: mapTemplateRef, memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 182:49: -> ^( MAP memberExpr mapTemplateRef )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:182:52: ^( MAP memberExpr mapTemplateRef )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:MAP Text:@"MAP"]
                                                                               old:root_1];

                        [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_1];
                        [treeAdaptor addChild:[stream_mapTemplateRef nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:183:49:  // alt
                {

                // AST REWRITE
                // elements: memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 183:49: -> memberExpr
                {
                    [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_0];

                }

                retval.tree = root_0;

                }
                break;

        }


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_COLON release];
        [stream_memberExpr release];
        [stream_mapTemplateRef release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end exprNoComma */

/*
 * $ANTLR start expr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:187:1: expr : mapExpr ;
 */
- (STParser_expr_return *) expr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_expr_return * retval = [STParser_expr_return newSTParser_expr_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STParser_mapExpr_return * mapExpr75 = nil;



        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:187:6: ( mapExpr ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:187:8: mapExpr // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_mapExpr_in_expr1362];
        mapExpr75 = [self mapExpr];

        [self popFollow];


        [treeAdaptor addChild:[mapExpr75 getTree] toTree:root_0];

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end expr */

/*
 * $ANTLR start mapExpr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:191:1: mapExpr : memberExpr ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) (col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* -> ^( MAP[$col] $mapExpr ( $x)+ ) )* ;
 */
- (STParser_mapExpr_return *) mapExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_mapExpr_return * retval = [STParser_mapExpr_return newSTParser_mapExpr_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *c = nil;
        ANTLRCommonToken *col = nil;
        ANTLRCommonToken *char_literal79 = nil;
        NSMutableArray *list_x = nil;
        STParser_memberExpr_return * memberExpr76 = nil;

        STParser_memberExpr_return * memberExpr77 = nil;

        STParser_mapTemplateRef_return * mapTemplateRef78 = nil;

        ANTLRParserRuleReturnScope *x = nil;
        ANTLRCommonTree *c_tree=nil;
        ANTLRCommonTree *col_tree=nil;
        ANTLRCommonTree *char_literal79_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_COLON = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COLON"] retain];
        ANTLRRewriteRuleTokenStream *stream_COMMA = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_memberExpr = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule memberExpr"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_mapTemplateRef = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapTemplateRef"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:192:5: ( memberExpr ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) (col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* -> ^( MAP[$col] $mapExpr ( $x)+ ) )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:192:9: memberExpr ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) (col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* -> ^( MAP[$col] $mapExpr ( $x)+ ) )* // alt
        {
        /* ruleRef */
        [self pushFollow:FOLLOW_memberExpr_in_mapExpr1379];
        memberExpr76 = [self memberExpr];

        [self popFollow];


        [stream_memberExpr addElement:[memberExpr76 getTree]];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:193:9: ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) // block
        NSInteger alt21=2;
        NSInteger LA21_0 = [input LA:1];

        if ( (LA21_0==COMMA) ) {
            alt21=1;
        }
        else if ( (LA21_0==SEMI||LA21_0==COLON||LA21_0==RPAREN||LA21_0==RDELIM) ) {
            alt21=2;
        }
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:21 state:0 stream:input];
            @throw nvae;
        }
        switch (alt21) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:193:11: (c= ',' memberExpr )+ col= ':' mapTemplateRef // alt
                {
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:193:11: (c= ',' memberExpr )+ // positiveClosureBlock
                NSInteger cnt20 = 0;
                do {
                    NSInteger alt20 = 2;
                    NSInteger LA20_0 = [input LA:1];
                    if ( (LA20_0==COMMA) ) {
                        alt20=1;
                    }


                    switch (alt20) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:193:12: c= ',' memberExpr // alt
                            {
                            c=(ANTLRCommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_mapExpr1394];  
                                [stream_COMMA addElement:c];

                            /* ruleRef */
                            [self pushFollow:FOLLOW_memberExpr_in_mapExpr1396];
                            memberExpr77 = [self memberExpr];

                            [self popFollow];


                            [stream_memberExpr addElement:[memberExpr77 getTree]];

                            }
                            break;

                        default :
                            if ( cnt20 >= 1 )
                                goto loop20;
                            ANTLREarlyExitException *eee = 
                                [ANTLREarlyExitException exceptionWithStream:input decisionNumber:20];
                            @throw eee;
                    }
                    cnt20++;
                } while (YES);
                loop20: ;

                col=(ANTLRCommonToken *)[self match:input TokenType:COLON Follow:FOLLOW_COLON_in_mapExpr1402];  
                    [stream_COLON addElement:col];

                /* ruleRef */
                [self pushFollow:FOLLOW_mapTemplateRef_in_mapExpr1404];
                mapTemplateRef78 = [self mapTemplateRef];

                [self popFollow];


                [stream_mapTemplateRef addElement:[mapTemplateRef78 getTree]];


                // AST REWRITE
                // elements: memberExpr, mapTemplateRef
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 194:49: -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:194:52: ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:ZIP FromToken:col Text:@"ZIP"]
                                                                               old:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:194:64: ^( ELEMENTS ( memberExpr )+ )
                        {
                            ANTLRCommonTree *root_2 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_2 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:ELEMENTS Text:@"ELEMENTS"]
                                                                                   old:root_2];

                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:194:75: ( memberExpr )+
                            {
                            if ( !([stream_memberExpr hasNext]) ) {
                                @throw [NSException exceptionWithName:@"RewriteEarlyExitException" reason:nil userInfo:nil];
                            }
                            while ( [stream_memberExpr hasNext] ) {
                                [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_2];

                            }
                            [stream_memberExpr reset];

                            }
                            [treeAdaptor addChild:root_2 toTree:root_1];
                        }
                        [treeAdaptor addChild:[stream_mapTemplateRef nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:195:49:  // alt
                {

                // AST REWRITE
                // elements: memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 195:49: -> memberExpr
                {
                    [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_0];

                }

                retval.tree = root_0;

                }
                break;

        }

        do {
            NSInteger alt23=2;
            NSInteger LA23_0 = [input LA:1];
            if ( (LA23_0==COLON) ) {
                alt23=1;
            }


            switch (alt23) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:197:13: col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* // alt
                    {
                    if (list_x != nil) [list_x clear];
                    col=(ANTLRCommonToken *)[self match:input TokenType:COLON Follow:FOLLOW_COLON_in_mapExpr1561];  
                        [stream_COLON addElement:col];

                    /* ruleRef */
                    [self pushFollow:FOLLOW_mapTemplateRef_in_mapExpr1565];
                    x = [self mapTemplateRef];

                    [self popFollow];


                    [stream_mapTemplateRef addElement:[x getTree]];
                    if (list_x == nil) list_x = [[NSMutableArray arrayWithCapacity:5] retain];
                    [list_x addObject:[x getTree]];

                    do {
                        NSInteger alt22=2;
                        NSInteger LA22_0 = [input LA:1];
                        if ( (LA22_0==COMMA) && ((c==nil))) {
                            alt22=1;
                        }


                        switch (alt22) {
                            case 1 : ;
                                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:198:40: {...}? => ',' x+= mapTemplateRef // alt
                                {
                                if ( !((c==nil)) ) {
                                    @throw [ANTLRFailedPredicateException exceptionWithRuleName:@"mapExpr" predicate:@"$c==nil" stream:input];
                                }
                                char_literal79=(ANTLRCommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_mapExpr1571];  
                                    [stream_COMMA addElement:char_literal79];

                                /* ruleRef */
                                [self pushFollow:FOLLOW_mapTemplateRef_in_mapExpr1575];
                                x = [self mapTemplateRef];

                                [self popFollow];


                                [stream_mapTemplateRef addElement:[x getTree]];
                                if (list_x == nil) list_x = [[NSMutableArray arrayWithCapacity:5] retain];
                                [list_x addObject:[x getTree]];


                                }
                                break;

                            default :
                                goto loop22;
                        }
                    } while (YES);
                    loop22: ;



                    // AST REWRITE
                    // elements: mapExpr, x
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: x
                    // wildcard labels: 
                    retval.tree = root_0;

                    ANTLRRewriteRuleSubtreeStream *stream_retval =
                        [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];
                    ANTLRRewriteRuleSubtreeStream *stream_x =
                        [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token x" elements:list_x] retain];
                    root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 199:49: -> ^( MAP[$col] $mapExpr ( $x)+ )
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:199:52: ^( MAP[$col] $mapExpr ( $x)+ )
                        {
                            ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:MAP FromToken:col Text:@"MAP"]
                                                                                   old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:199:73: ( $x)+
                            {
                            if ( !([stream_x hasNext]) ) {
                                @throw [NSException exceptionWithName:@"RewriteEarlyExitException" reason:nil userInfo:nil];
                            }
                            while ( [stream_x hasNext] ) {
                                [treeAdaptor addChild:[stream_x nextTree] toTree:root_1];

                            }
                            [stream_x reset];

                            }
                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }

                    retval.tree = root_0;

                    }
                    break;

                default :
                    goto loop23;
            }
        } while (YES);
        loop23: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [list_x release];
        [retval setStop:[input LT:-1]];

        [stream_COLON release];
        [stream_COMMA release];
        [stream_memberExpr release];
        [stream_mapTemplateRef release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end mapExpr */

/*
 * $ANTLR start mapTemplateRef
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:203:1: mapTemplateRef : ( ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | subtemplate | lp= '(' mapExpr rp= ')' '(' ( argExprList )? ')' -> ^( INCLUDE_IND mapExpr ( argExprList )? ) );
 */
- (STParser_mapTemplateRef_return *) mapTemplateRef
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_mapTemplateRef_return * retval = [STParser_mapTemplateRef_return newSTParser_mapTemplateRef_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *lp = nil;
        ANTLRCommonToken *rp = nil;
        ANTLRCommonToken *ID80 = nil;
        ANTLRCommonToken *char_literal81 = nil;
        ANTLRCommonToken *char_literal83 = nil;
        ANTLRCommonToken *char_literal86 = nil;
        ANTLRCommonToken *char_literal88 = nil;
        STParser_args_return * args82 = nil;

        STParser_subtemplate_return * subtemplate84 = nil;

        STParser_mapExpr_return * mapExpr85 = nil;

        STParser_argExprList_return * argExprList87 = nil;


        ANTLRCommonTree *lp_tree=nil;
        ANTLRCommonTree *rp_tree=nil;
        ANTLRCommonTree *ID80_tree=nil;
        ANTLRCommonTree *char_literal81_tree=nil;
        ANTLRCommonTree *char_literal83_tree=nil;
        ANTLRCommonTree *char_literal86_tree=nil;
        ANTLRCommonTree *char_literal88_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_RPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        ANTLRRewriteRuleTokenStream *stream_ID = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        ANTLRRewriteRuleTokenStream *stream_LPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_argExprList = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule argExprList"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_args = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule args"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_mapExpr = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapExpr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:209:5: ( ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | subtemplate | lp= '(' mapExpr rp= ')' '(' ( argExprList )? ')' -> ^( INCLUDE_IND mapExpr ( argExprList )? ) ) //ruleblock
        NSInteger alt25=3;
        switch ([input LA:1]) {
            case ID: ;
                {
                alt25=1;
                }
                break;
            case LCURLY: ;
                {
                alt25=2;
                }
                break;
            case LPAREN: ;
                {
                alt25=3;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:25 state:0 stream:input];
            @throw nvae;
        }

        switch (alt25) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:209:9: ID '(' args ')' // alt
                {
                ID80=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_mapTemplateRef1672];  
                    [stream_ID addElement:ID80];

                char_literal81=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_mapTemplateRef1674];  
                    [stream_LPAREN addElement:char_literal81];

                /* ruleRef */
                [self pushFollow:FOLLOW_args_in_mapTemplateRef1676];
                args82 = [self args];

                [self popFollow];


                [stream_args addElement:[args82 getTree]];
                char_literal83=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_mapTemplateRef1678];  
                    [stream_RPAREN addElement:char_literal83];



                // AST REWRITE
                // elements: args, ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 209:49: -> ^( INCLUDE ID ( args )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:209:52: ^( INCLUDE ID ( args )? )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:INCLUDE Text:@"INCLUDE"]
                                                                               old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:209:65: ( args )?
                        if ( [stream_args hasNext] ) {
                        	[treeAdaptor addChild:[stream_args nextTree] toTree:root_1];

                        }
                        [stream_args reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:210:9: subtemplate // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_subtemplate_in_mapTemplateRef1723];
                subtemplate84 = [self subtemplate];

                [self popFollow];


                [treeAdaptor addChild:[subtemplate84 getTree] toTree:root_0];

                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:211:9: lp= '(' mapExpr rp= ')' '(' ( argExprList )? ')' // alt
                {
                lp=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_mapTemplateRef1735];  
                    [stream_LPAREN addElement:lp];

                /* ruleRef */
                [self pushFollow:FOLLOW_mapExpr_in_mapTemplateRef1737];
                mapExpr85 = [self mapExpr];

                [self popFollow];


                [stream_mapExpr addElement:[mapExpr85 getTree]];
                rp=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_mapTemplateRef1741];  
                    [stream_RPAREN addElement:rp];

                char_literal86=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_mapTemplateRef1743];  
                    [stream_LPAREN addElement:char_literal86];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:211:35: ( argExprList )? // block
                NSInteger alt24=2;
                NSInteger LA24_0 = [input LA:1];

                if ( (LA24_0==SUPER||LA24_0==LPAREN||LA24_0==LBRACK||LA24_0==LCURLY||(LA24_0>=ID && LA24_0<=STRING)||LA24_0==AT) ) {
                    alt24=1;
                }
                switch (alt24) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:211:35: argExprList // alt
                        {
                        /* ruleRef */
                        [self pushFollow:FOLLOW_argExprList_in_mapTemplateRef1745];
                        argExprList87 = [self argExprList];

                        [self popFollow];


                        [stream_argExprList addElement:[argExprList87 getTree]];

                        }
                        break;

                }

                char_literal88=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_mapTemplateRef1748];  
                    [stream_RPAREN addElement:char_literal88];



                // AST REWRITE
                // elements: argExprList, mapExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 211:51: -> ^( INCLUDE_IND mapExpr ( argExprList )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:211:54: ^( INCLUDE_IND mapExpr ( argExprList )? )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:INCLUDE_IND Text:@"INCLUDE_IND"]
                                                                               old:root_1];

                        [treeAdaptor addChild:[stream_mapExpr nextTree] toTree:root_1];
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:211:76: ( argExprList )?
                        if ( [stream_argExprList hasNext] ) {
                        	[treeAdaptor addChild:[stream_argExprList nextTree] toTree:root_1];

                        }
                        [stream_argExprList reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_RPAREN release];
        [stream_ID release];
        [stream_LPAREN release];
        [stream_argExprList release];
        [stream_args release];
        [stream_mapExpr release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end mapTemplateRef */

/*
 * $ANTLR start memberExpr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:214:1: memberExpr : ( includeExpr -> includeExpr ) (p= '.' ID -> ^( PROP[$p,@\"PROP\"] $memberExpr ID ) | p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr ) )* ;
 */
- (STParser_memberExpr_return *) memberExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_memberExpr_return * retval = [STParser_memberExpr_return newSTParser_memberExpr_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *p = nil;
        ANTLRCommonToken *ID90 = nil;
        ANTLRCommonToken *char_literal91 = nil;
        ANTLRCommonToken *char_literal93 = nil;
        STParser_includeExpr_return * includeExpr89 = nil;

        STParser_mapExpr_return * mapExpr92 = nil;


        ANTLRCommonTree *p_tree=nil;
        ANTLRCommonTree *ID90_tree=nil;
        ANTLRCommonTree *char_literal91_tree=nil;
        ANTLRCommonTree *char_literal93_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_RPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        ANTLRRewriteRuleTokenStream *stream_DOT = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token DOT"] retain];
        ANTLRRewriteRuleTokenStream *stream_ID = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        ANTLRRewriteRuleTokenStream *stream_LPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_includeExpr = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule includeExpr"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_mapExpr = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapExpr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:215:5: ( ( includeExpr -> includeExpr ) (p= '.' ID -> ^( PROP[$p,@\"PROP\"] $memberExpr ID ) | p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr ) )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:215:9: ( includeExpr -> includeExpr ) (p= '.' ID -> ^( PROP[$p,@\"PROP\"] $memberExpr ID ) | p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr ) )* // alt
        {
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:215:9: ( includeExpr -> includeExpr ) // blockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:215:10: includeExpr // alt
        {
        /* ruleRef */
        [self pushFollow:FOLLOW_includeExpr_in_memberExpr1778];
        includeExpr89 = [self includeExpr];

        [self popFollow];


        [stream_includeExpr addElement:[includeExpr89 getTree]];


        // AST REWRITE
        // elements: includeExpr
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 215:21: -> includeExpr
        {
            [treeAdaptor addChild:[stream_includeExpr nextTree] toTree:root_0];

        }

        retval.tree = root_0;

        }

        do {
            NSInteger alt26=3;
            NSInteger LA26_0 = [input LA:1];
            if ( (LA26_0==DOT) ) {
                NSInteger LA26_2 = [input LA:2];
                if ( (LA26_2==ID) ) {
                    alt26=1;
                }
                else if ( (LA26_2==LPAREN) ) {
                    alt26=2;
                }


            }


            switch (alt26) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:216:13: p= '.' ID // alt
                    {
                    p=(ANTLRCommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_memberExpr1797];  
                        [stream_DOT addElement:p];

                    ID90=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_memberExpr1799];  
                        [stream_ID addElement:ID90];



                    // AST REWRITE
                    // elements: ID, memberExpr
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    ANTLRRewriteRuleSubtreeStream *stream_retval =
                        [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                    root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 216:49: -> ^( PROP[$p,@\"PROP\"] $memberExpr ID )
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:216:52: ^( PROP[$p,@\"PROP\"] $memberExpr ID )
                        {
                            ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:PROP FromToken:p Text:@"PROP"]
                                                                                   old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];
                             // TODO: args: 
                            [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }

                    retval.tree = root_0;

                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:217:13: p= '.' '(' mapExpr ')' // alt
                    {
                    p=(ANTLRCommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_memberExpr1854];  
                        [stream_DOT addElement:p];

                    char_literal91=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_memberExpr1856];  
                        [stream_LPAREN addElement:char_literal91];

                    /* ruleRef */
                    [self pushFollow:FOLLOW_mapExpr_in_memberExpr1858];
                    mapExpr92 = [self mapExpr];

                    [self popFollow];


                    [stream_mapExpr addElement:[mapExpr92 getTree]];
                    char_literal93=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_memberExpr1860];  
                        [stream_RPAREN addElement:char_literal93];



                    // AST REWRITE
                    // elements: memberExpr, mapExpr
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    ANTLRRewriteRuleSubtreeStream *stream_retval =
                        [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                    root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 217:49: -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr )
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:217:52: ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr )
                        {
                            ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:PROP_IND FromToken:p Text:@"PROP_IND"]
                                                                                   old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];
                            [treeAdaptor addChild:[stream_mapExpr nextTree] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }

                    retval.tree = root_0;

                    }
                    break;

                default :
                    goto loop26;
            }
        } while (YES);
        loop26: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_RPAREN release];
        [stream_DOT release];
        [stream_ID release];
        [stream_LPAREN release];
        [stream_includeExpr release];
        [stream_mapExpr release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end memberExpr */

/*
 * $ANTLR start includeExpr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:221:1: includeExpr options {k=2; } : ({...}? ID '(' ( expr )? ')' -> ^( EXEC_FUNC ID ( expr )? ) | 'super' '.' ID '(' args ')' -> ^( INCLUDE_SUPER ID ( args )? ) | ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | '@' 'super' '.' ID '(' rp= ')' -> ^( INCLUDE_SUPER_REGION ID ) | '@' ID '(' rp= ')' -> ^( INCLUDE_REGION ID ) | primary );
 */
- (STParser_includeExpr_return *) includeExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_includeExpr_return * retval = [STParser_includeExpr_return newSTParser_includeExpr_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *rp = nil;
        ANTLRCommonToken *ID94 = nil;
        ANTLRCommonToken *char_literal95 = nil;
        ANTLRCommonToken *char_literal97 = nil;
        ANTLRCommonToken *string_literal98 = nil;
        ANTLRCommonToken *char_literal99 = nil;
        ANTLRCommonToken *ID100 = nil;
        ANTLRCommonToken *char_literal101 = nil;
        ANTLRCommonToken *char_literal103 = nil;
        ANTLRCommonToken *ID104 = nil;
        ANTLRCommonToken *char_literal105 = nil;
        ANTLRCommonToken *char_literal107 = nil;
        ANTLRCommonToken *char_literal108 = nil;
        ANTLRCommonToken *string_literal109 = nil;
        ANTLRCommonToken *char_literal110 = nil;
        ANTLRCommonToken *ID111 = nil;
        ANTLRCommonToken *char_literal112 = nil;
        ANTLRCommonToken *char_literal113 = nil;
        ANTLRCommonToken *ID114 = nil;
        ANTLRCommonToken *char_literal115 = nil;
        STParser_expr_return * expr96 = nil;

        STParser_args_return * args102 = nil;

        STParser_args_return * args106 = nil;

        STParser_primary_return * primary116 = nil;


        ANTLRCommonTree *rp_tree=nil;
        ANTLRCommonTree *ID94_tree=nil;
        ANTLRCommonTree *char_literal95_tree=nil;
        ANTLRCommonTree *char_literal97_tree=nil;
        ANTLRCommonTree *string_literal98_tree=nil;
        ANTLRCommonTree *char_literal99_tree=nil;
        ANTLRCommonTree *ID100_tree=nil;
        ANTLRCommonTree *char_literal101_tree=nil;
        ANTLRCommonTree *char_literal103_tree=nil;
        ANTLRCommonTree *ID104_tree=nil;
        ANTLRCommonTree *char_literal105_tree=nil;
        ANTLRCommonTree *char_literal107_tree=nil;
        ANTLRCommonTree *char_literal108_tree=nil;
        ANTLRCommonTree *string_literal109_tree=nil;
        ANTLRCommonTree *char_literal110_tree=nil;
        ANTLRCommonTree *ID111_tree=nil;
        ANTLRCommonTree *char_literal112_tree=nil;
        ANTLRCommonTree *char_literal113_tree=nil;
        ANTLRCommonTree *ID114_tree=nil;
        ANTLRCommonTree *char_literal115_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_AT = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token AT"] retain];
        ANTLRRewriteRuleTokenStream *stream_RPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        ANTLRRewriteRuleTokenStream *stream_SUPER = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token SUPER"] retain];
        ANTLRRewriteRuleTokenStream *stream_DOT = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token DOT"] retain];
        ANTLRRewriteRuleTokenStream *stream_ID = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        ANTLRRewriteRuleTokenStream *stream_LPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_args = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule args"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_expr = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:223:5: ({...}? ID '(' ( expr )? ')' -> ^( EXEC_FUNC ID ( expr )? ) | 'super' '.' ID '(' args ')' -> ^( INCLUDE_SUPER ID ( args )? ) | ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | '@' 'super' '.' ID '(' rp= ')' -> ^( INCLUDE_SUPER_REGION ID ) | '@' ID '(' rp= ')' -> ^( INCLUDE_REGION ID ) | primary ) //ruleblock
        NSInteger alt28=6;
        alt28 = [dfa28 predict:input];
        switch (alt28) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:223:9: {...}? ID '(' ( expr )? ')' // alt
                {
                if ( !(([[Compiler funcs] objectForKey:[[input LT:1] getText]])) ) {
                    @throw [ANTLRFailedPredicateException exceptionWithRuleName:@"includeExpr" predicate:@"[[Compiler funcs] objectForKey:[[input LT:1] getText]]" stream:input];
                }
                ID94=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr1935];  
                    [stream_ID addElement:ID94];

                char_literal95=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr1937];  
                    [stream_LPAREN addElement:char_literal95];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:224:16: ( expr )? // block
                NSInteger alt27=2;
                NSInteger LA27_0 = [input LA:1];

                if ( (LA27_0==SUPER||LA27_0==LPAREN||LA27_0==LBRACK||LA27_0==LCURLY||(LA27_0>=ID && LA27_0<=STRING)||LA27_0==AT) ) {
                    alt27=1;
                }
                switch (alt27) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:224:16: expr // alt
                        {
                        /* ruleRef */
                        [self pushFollow:FOLLOW_expr_in_includeExpr1939];
                        expr96 = [self expr];

                        [self popFollow];


                        [stream_expr addElement:[expr96 getTree]];

                        }
                        break;

                }

                char_literal97=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr1942];  
                    [stream_RPAREN addElement:char_literal97];



                // AST REWRITE
                // elements: ID, expr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 224:49: -> ^( EXEC_FUNC ID ( expr )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:224:52: ^( EXEC_FUNC ID ( expr )? )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:EXEC_FUNC Text:@"EXEC_FUNC"]
                                                                               old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:224:67: ( expr )?
                        if ( [stream_expr hasNext] ) {
                        	[treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                        }
                        [stream_expr reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:225:9: 'super' '.' ID '(' args ')' // alt
                {
                string_literal98=(ANTLRCommonToken *)[self match:input TokenType:SUPER Follow:FOLLOW_SUPER_in_includeExpr1986];  
                    [stream_SUPER addElement:string_literal98];

                char_literal99=(ANTLRCommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_includeExpr1988];  
                    [stream_DOT addElement:char_literal99];

                ID100=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr1990];  
                    [stream_ID addElement:ID100];

                char_literal101=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr1992];  
                    [stream_LPAREN addElement:char_literal101];

                /* ruleRef */
                [self pushFollow:FOLLOW_args_in_includeExpr1994];
                args102 = [self args];

                [self popFollow];


                [stream_args addElement:[args102 getTree]];
                char_literal103=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr1996];  
                    [stream_RPAREN addElement:char_literal103];



                // AST REWRITE
                // elements: ID, args
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 225:49: -> ^( INCLUDE_SUPER ID ( args )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:225:52: ^( INCLUDE_SUPER ID ( args )? )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:INCLUDE_SUPER Text:@"INCLUDE_SUPER"]
                                                                               old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:225:71: ( args )?
                        if ( [stream_args hasNext] ) {
                        	[treeAdaptor addChild:[stream_args nextTree] toTree:root_1];

                        }
                        [stream_args reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:226:9: ID '(' args ')' // alt
                {
                ID104=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2029];  
                    [stream_ID addElement:ID104];

                char_literal105=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2031];  
                    [stream_LPAREN addElement:char_literal105];

                /* ruleRef */
                [self pushFollow:FOLLOW_args_in_includeExpr2033];
                args106 = [self args];

                [self popFollow];


                [stream_args addElement:[args106 getTree]];
                char_literal107=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2035];  
                    [stream_RPAREN addElement:char_literal107];



                // AST REWRITE
                // elements: args, ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 226:49: -> ^( INCLUDE ID ( args )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:226:52: ^( INCLUDE ID ( args )? )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:INCLUDE Text:@"INCLUDE"]
                                                                               old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:226:65: ( args )?
                        if ( [stream_args hasNext] ) {
                        	[treeAdaptor addChild:[stream_args nextTree] toTree:root_1];

                        }
                        [stream_args reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:227:9: '@' 'super' '.' ID '(' rp= ')' // alt
                {
                char_literal108=(ANTLRCommonToken *)[self match:input TokenType:AT Follow:FOLLOW_AT_in_includeExpr2080];  
                    [stream_AT addElement:char_literal108];

                string_literal109=(ANTLRCommonToken *)[self match:input TokenType:SUPER Follow:FOLLOW_SUPER_in_includeExpr2082];  
                    [stream_SUPER addElement:string_literal109];

                char_literal110=(ANTLRCommonToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_includeExpr2084];  
                    [stream_DOT addElement:char_literal110];

                ID111=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2086];  
                    [stream_ID addElement:ID111];

                char_literal112=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2088];  
                    [stream_LPAREN addElement:char_literal112];

                rp=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2092];  
                    [stream_RPAREN addElement:rp];



                // AST REWRITE
                // elements: ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 227:49: -> ^( INCLUDE_SUPER_REGION ID )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:227:52: ^( INCLUDE_SUPER_REGION ID )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:INCLUDE_SUPER_REGION Text:@"INCLUDE_SUPER_REGION"]
                                                                               old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;
            case 5 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:228:9: '@' ID '(' rp= ')' // alt
                {
                char_literal113=(ANTLRCommonToken *)[self match:input TokenType:AT Follow:FOLLOW_AT_in_includeExpr2120];  
                    [stream_AT addElement:char_literal113];

                ID114=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2122];  
                    [stream_ID addElement:ID114];

                char_literal115=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2124];  
                    [stream_LPAREN addElement:char_literal115];

                rp=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2128];  
                    [stream_RPAREN addElement:rp];



                // AST REWRITE
                // elements: ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 228:49: -> ^( INCLUDE_REGION ID )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:228:52: ^( INCLUDE_REGION ID )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:INCLUDE_REGION Text:@"INCLUDE_REGION"]
                                                                               old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;
            case 6 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:229:9: primary // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_primary_in_includeExpr2168];
                primary116 = [self primary];

                [self popFollow];


                [treeAdaptor addChild:[primary116 getTree] toTree:root_0];

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_AT release];
        [stream_RPAREN release];
        [stream_SUPER release];
        [stream_DOT release];
        [stream_ID release];
        [stream_LPAREN release];
        [stream_args release];
        [stream_expr release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end includeExpr */

/*
 * $ANTLR start primary
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:232:1: primary : ( ID | STRING | subtemplate | list | lp= '(' expr ')' ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) );
 */
- (STParser_primary_return *) primary
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_primary_return * retval = [STParser_primary_return newSTParser_primary_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *lp = nil;
        ANTLRCommonToken *ID117 = nil;
        ANTLRCommonToken *STRING118 = nil;
        ANTLRCommonToken *char_literal122 = nil;
        ANTLRCommonToken *char_literal123 = nil;
        ANTLRCommonToken *char_literal125 = nil;
        STParser_subtemplate_return * subtemplate119 = nil;

        STParser_list_return * list120 = nil;

        STParser_expr_return * expr121 = nil;

        STParser_argExprList_return * argExprList124 = nil;


        ANTLRCommonTree *lp_tree=nil;
        ANTLRCommonTree *ID117_tree=nil;
        ANTLRCommonTree *STRING118_tree=nil;
        ANTLRCommonTree *char_literal122_tree=nil;
        ANTLRCommonTree *char_literal123_tree=nil;
        ANTLRCommonTree *char_literal125_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_RPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        ANTLRRewriteRuleTokenStream *stream_LPAREN = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_argExprList = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule argExprList"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_expr = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:233:5: ( ID | STRING | subtemplate | list | lp= '(' expr ')' ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) ) //ruleblock
        NSInteger alt31=5;
        switch ([input LA:1]) {
            case ID: ;
                {
                alt31=1;
                }
                break;
            case STRING: ;
                {
                alt31=2;
                }
                break;
            case LCURLY: ;
                {
                alt31=3;
                }
                break;
            case LBRACK: ;
                {
                alt31=4;
                }
                break;
            case LPAREN: ;
                {
                alt31=5;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:31 state:0 stream:input];
            @throw nvae;
        }

        switch (alt31) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:233:9: ID // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser tokenRef */
                ID117=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_primary2187]; 
                ID117_tree = /* ASTParser createNodeFromToken */
                (ANTLRCommonTree *)[[treeAdaptor createTree:ID117] retain];
                [treeAdaptor addChild:ID117_tree  toTree:root_0];


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:234:9: STRING // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser tokenRef */
                STRING118=(ANTLRCommonToken *)[self match:input TokenType:STRING Follow:FOLLOW_STRING_in_primary2197]; 
                STRING118_tree = /* ASTParser createNodeFromToken */
                (ANTLRCommonTree *)[[treeAdaptor createTree:STRING118] retain];
                [treeAdaptor addChild:STRING118_tree  toTree:root_0];


                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:235:9: subtemplate // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_subtemplate_in_primary2207];
                subtemplate119 = [self subtemplate];

                [self popFollow];


                [treeAdaptor addChild:[subtemplate119 getTree] toTree:root_0];

                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:236:9: list // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_list_in_primary2217];
                list120 = [self list];

                [self popFollow];


                [treeAdaptor addChild:[list120 getTree] toTree:root_0];

                }
                break;
            case 5 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:237:9: lp= '(' expr ')' ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) // alt
                {
                lp=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_primary2229];  
                    [stream_LPAREN addElement:lp];

                /* ruleRef */
                [self pushFollow:FOLLOW_expr_in_primary2231];
                expr121 = [self expr];

                [self popFollow];


                [stream_expr addElement:[expr121 getTree]];
                char_literal122=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_primary2233];  
                    [stream_RPAREN addElement:char_literal122];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:238:9: ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) // block
                NSInteger alt30=2;
                NSInteger LA30_0 = [input LA:1];

                if ( (LA30_0==LPAREN) ) {
                    alt30=1;
                }
                else if ( (LA30_0==SEMI||LA30_0==COLON||LA30_0==RPAREN||(LA30_0>=RBRACK && LA30_0<=DOT)||LA30_0==RDELIM||(LA30_0>=OR && LA30_0<=AND)) ) {
                    alt30=2;
                }
                else {
                    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:30 state:0 stream:input];
                    @throw nvae;
                }
                switch (alt30) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:238:13: '(' ( argExprList )? ')' // alt
                        {
                        char_literal123=(ANTLRCommonToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_primary2247];  
                            [stream_LPAREN addElement:char_literal123];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:238:17: ( argExprList )? // block
                        NSInteger alt29=2;
                        NSInteger LA29_0 = [input LA:1];

                        if ( (LA29_0==SUPER||LA29_0==LPAREN||LA29_0==LBRACK||LA29_0==LCURLY||(LA29_0>=ID && LA29_0<=STRING)||LA29_0==AT) ) {
                            alt29=1;
                        }
                        switch (alt29) {
                            case 1 : ;
                                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:238:17: argExprList // alt
                                {
                                /* ruleRef */
                                [self pushFollow:FOLLOW_argExprList_in_primary2249];
                                argExprList124 = [self argExprList];

                                [self popFollow];


                                [stream_argExprList addElement:[argExprList124 getTree]];

                                }
                                break;

                        }

                        char_literal125=(ANTLRCommonToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_primary2252];  
                            [stream_RPAREN addElement:char_literal125];



                        // AST REWRITE
                        // elements: argExprList, expr
                        // token labels: 
                        // rule labels: retval
                        // token list labels: 
                        // rule list labels: 
                        // wildcard labels: 
                        retval.tree = root_0;

                        ANTLRRewriteRuleSubtreeStream *stream_retval =
                            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                        // 238:49: -> ^( INCLUDE_IND[$lp] expr ( argExprList )? )
                        {
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:238:52: ^( INCLUDE_IND[$lp] expr ( argExprList )? )
                            {
                                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:INCLUDE_IND FromToken:lp Text:@"INCLUDE_IND"]
                                                                                       old:root_1];

                                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];
                                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:238:76: ( argExprList )?
                                if ( [stream_argExprList hasNext] ) {
                                	[treeAdaptor addChild:[stream_argExprList nextTree] toTree:root_1];

                                }
                                [stream_argExprList reset];

                                [treeAdaptor addChild:root_1 toTree:root_0];
                            }

                        }

                        retval.tree = root_0;

                        }
                        break;
                    case 2 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:239:49:  // alt
                        {

                        // AST REWRITE
                        // elements: expr
                        // token labels: 
                        // rule labels: retval
                        // token list labels: 
                        // rule list labels: 
                        // wildcard labels: 
                        retval.tree = root_0;

                        ANTLRRewriteRuleSubtreeStream *stream_retval =
                            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                        // 239:49: -> ^( TO_STR[$lp] expr )
                        {
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:239:52: ^( TO_STR[$lp] expr )
                            {
                                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:TO_STR FromToken:lp Text:@"TO_STR"]
                                                                                       old:root_1];

                                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                                [treeAdaptor addChild:root_1 toTree:root_0];
                            }

                        }

                        retval.tree = root_0;

                        }
                        break;

                }


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_RPAREN release];
        [stream_LPAREN release];
        [stream_argExprList release];
        [stream_expr release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end primary */

/*
 * $ANTLR start args
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:243:1: args : ( argExprList | namedArg ( ',' namedArg )* -> ( namedArg )+ | );
 */
- (STParser_args_return *) args
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_args_return * retval = [STParser_args_return newSTParser_args_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *char_literal128 = nil;
        STParser_argExprList_return * argExprList126 = nil;

        STParser_namedArg_return * namedArg127 = nil;

        STParser_namedArg_return * namedArg129 = nil;


        ANTLRCommonTree *char_literal128_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_COMMA = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_namedArg = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule namedArg"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:243:5: ( argExprList | namedArg ( ',' namedArg )* -> ( namedArg )+ | ) //ruleblock
        NSInteger alt33=3;
        switch ([input LA:1]) {
            case ID: ;
                {
                NSInteger LA33_1 = [input LA:2];

                if ( ((LA33_1>=COLON && LA33_1<=RPAREN)||(LA33_1>=COMMA && LA33_1<=DOT)) ) {
                    alt33=1;
                }
                else if ( (LA33_1==EQUALS) ) {
                    alt33=2;
                }
                else {
                    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:33 state:1 stream:input];
                    @throw nvae;
                }
                }
                break;
            case SUPER: ;
            case LPAREN: ;
            case LBRACK: ;
            case LCURLY: ;
            case STRING: ;
            case AT: ;
                {
                alt33=1;
                }
                break;
            case RPAREN: ;
                {
                alt33=3;
                }
                break;

        default: ;
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:33 state:0 stream:input];
            @throw nvae;
        }

        switch (alt33) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:243:9: argExprList // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_argExprList_in_args2360];
                argExprList126 = [self argExprList];

                [self popFollow];


                [treeAdaptor addChild:[argExprList126 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:244:9: namedArg ( ',' namedArg )* // alt
                {
                /* ruleRef */
                [self pushFollow:FOLLOW_namedArg_in_args2370];
                namedArg127 = [self namedArg];

                [self popFollow];


                [stream_namedArg addElement:[namedArg127 getTree]];
                do {
                    NSInteger alt32=2;
                    NSInteger LA32_0 = [input LA:1];
                    if ( (LA32_0==COMMA) ) {
                        alt32=1;
                    }


                    switch (alt32) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:244:20: ',' namedArg // alt
                            {
                            char_literal128=(ANTLRCommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_args2374];  
                                [stream_COMMA addElement:char_literal128];

                            /* ruleRef */
                            [self pushFollow:FOLLOW_namedArg_in_args2376];
                            namedArg129 = [self namedArg];

                            [self popFollow];


                            [stream_namedArg addElement:[namedArg129 getTree]];

                            }
                            break;

                        default :
                            goto loop32;
                    }
                } while (YES);
                loop32: ;



                // AST REWRITE
                // elements: namedArg
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 244:36: -> ( namedArg )+
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:244:39: ( namedArg )+
                    {
                    if ( !([stream_namedArg hasNext]) ) {
                        @throw [NSException exceptionWithName:@"RewriteEarlyExitException" reason:nil userInfo:nil];
                    }
                    while ( [stream_namedArg hasNext] ) {
                        [treeAdaptor addChild:[stream_namedArg nextTree] toTree:root_0];

                    }
                    [stream_namedArg reset];

                    }
                }

                retval.tree = root_0;

                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:246:5:  // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_COMMA release];
        [stream_namedArg release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end args */

/*
 * $ANTLR start argExprList
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:248:1: argExprList : arg ( ',' arg )* -> ( arg )+ ;
 */
- (STParser_argExprList_return *) argExprList
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_argExprList_return * retval = [STParser_argExprList_return newSTParser_argExprList_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *char_literal131 = nil;
        STParser_arg_return * arg130 = nil;

        STParser_arg_return * arg132 = nil;


        ANTLRCommonTree *char_literal131_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_COMMA = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_arg = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule arg"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:248:13: ( arg ( ',' arg )* -> ( arg )+ ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:248:15: arg ( ',' arg )* // alt
        {
        /* ruleRef */
        [self pushFollow:FOLLOW_arg_in_argExprList2403];
        arg130 = [self arg];

        [self popFollow];


        [stream_arg addElement:[arg130 getTree]];
        do {
            NSInteger alt34=2;
            NSInteger LA34_0 = [input LA:1];
            if ( (LA34_0==COMMA) ) {
                alt34=1;
            }


            switch (alt34) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:248:21: ',' arg // alt
                    {
                    char_literal131=(ANTLRCommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_argExprList2407];  
                        [stream_COMMA addElement:char_literal131];

                    /* ruleRef */
                    [self pushFollow:FOLLOW_arg_in_argExprList2409];
                    arg132 = [self arg];

                    [self popFollow];


                    [stream_arg addElement:[arg132 getTree]];

                    }
                    break;

                default :
                    goto loop34;
            }
        } while (YES);
        loop34: ;



        // AST REWRITE
        // elements: arg
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 248:32: -> ( arg )+
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:248:35: ( arg )+
            {
            if ( !([stream_arg hasNext]) ) {
                @throw [NSException exceptionWithName:@"RewriteEarlyExitException" reason:nil userInfo:nil];
            }
            while ( [stream_arg hasNext] ) {
                [treeAdaptor addChild:[stream_arg nextTree] toTree:root_0];

            }
            [stream_arg reset];

            }
        }

        retval.tree = root_0;

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_COMMA release];
        [stream_arg release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end argExprList */

/*
 * $ANTLR start arg
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:250:1: arg : exprNoComma ;
 */
- (STParser_arg_return *) arg
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_arg_return * retval = [STParser_arg_return newSTParser_arg_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STParser_exprNoComma_return * exprNoComma133 = nil;



        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:250:5: ( exprNoComma ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:250:7: exprNoComma // alt
        {
        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_exprNoComma_in_arg2426];
        exprNoComma133 = [self exprNoComma];

        [self popFollow];


        [treeAdaptor addChild:[exprNoComma133 getTree] toTree:root_0];

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end arg */

/*
 * $ANTLR start namedArg
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:252:1: namedArg : ID '=' arg -> ^( '=' ID arg ) ;
 */
- (STParser_namedArg_return *) namedArg
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_namedArg_return * retval = [STParser_namedArg_return newSTParser_namedArg_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *ID134 = nil;
        ANTLRCommonToken *char_literal135 = nil;
        STParser_arg_return * arg136 = nil;


        ANTLRCommonTree *ID134_tree=nil;
        ANTLRCommonTree *char_literal135_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_EQUALS = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token EQUALS"] retain];
        ANTLRRewriteRuleTokenStream *stream_ID = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_arg = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule arg"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:252:10: ( ID '=' arg -> ^( '=' ID arg ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:252:12: ID '=' arg // alt
        {
        ID134=(ANTLRCommonToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_namedArg2435];  
            [stream_ID addElement:ID134];

        char_literal135=(ANTLRCommonToken *)[self match:input TokenType:EQUALS Follow:FOLLOW_EQUALS_in_namedArg2437];  
            [stream_EQUALS addElement:char_literal135];

        /* ruleRef */
        [self pushFollow:FOLLOW_arg_in_namedArg2439];
        arg136 = [self arg];

        [self popFollow];


        [stream_arg addElement:[arg136 getTree]];


        // AST REWRITE
        // elements: EQUALS, arg, ID
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        ANTLRRewriteRuleSubtreeStream *stream_retval =
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 252:23: -> ^( '=' ID arg )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:252:26: ^( '=' ID arg )
            {
                ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [stream_EQUALS nextNode] old:root_1];

                 // TODO: args: 
                [treeAdaptor addChild:        [stream_ID nextNode] toTree:root_1];
                [treeAdaptor addChild:[stream_arg nextTree] toTree:root_1];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        retval.tree = root_0;

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_EQUALS release];
        [stream_ID release];
        [stream_arg release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end namedArg */

/*
 * $ANTLR start list
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:254:1: list : ({...}?lb= '[' ']' -> LIST[$lb] | lb= '[' listElement ( ',' listElement )* ']' -> ^( LIST[$lb] ( listElement )* ) );
 */
- (STParser_list_return *) list
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_list_return * retval = [STParser_list_return newSTParser_list_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        ANTLRCommonToken *lb = nil;
        ANTLRCommonToken *char_literal137 = nil;
        ANTLRCommonToken *char_literal139 = nil;
        ANTLRCommonToken *char_literal141 = nil;
        STParser_listElement_return * listElement138 = nil;

        STParser_listElement_return * listElement140 = nil;


        ANTLRCommonTree *lb_tree=nil;
        ANTLRCommonTree *char_literal137_tree=nil;
        ANTLRCommonTree *char_literal139_tree=nil;
        ANTLRCommonTree *char_literal141_tree=nil;
        ANTLRRewriteRuleTokenStream *stream_RBRACK = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RBRACK"] retain];
        ANTLRRewriteRuleTokenStream *stream_LBRACK = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LBRACK"] retain];
        ANTLRRewriteRuleTokenStream *stream_COMMA = 
            [[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        ANTLRRewriteRuleSubtreeStream *stream_listElement = 
            [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule listElement"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:254:5: ({...}?lb= '[' ']' -> LIST[$lb] | lb= '[' listElement ( ',' listElement )* ']' -> ^( LIST[$lb] ( listElement )* ) ) //ruleblock
        NSInteger alt36=2;
        NSInteger LA36_0 = [input LA:1];

        if ( (LA36_0==LBRACK) ) {
            NSInteger LA36_1 = [input LA:2];

            if ( (LA36_1==RBRACK) ) {
                NSInteger LA36_2 = [input LA:3];

                if ( (([input LA:2] == RBRACK)) ) {
                    alt36=1;
                }
                else if ( (YES) ) {
                    alt36=2;
                }
                else {
                    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:36 state:2 stream:input];
                    @throw nvae;
                }
            }
            else if ( (LA36_1==SUPER||LA36_1==LPAREN||LA36_1==LBRACK||LA36_1==COMMA||LA36_1==LCURLY||(LA36_1>=ID && LA36_1<=STRING)||LA36_1==AT) ) {
                alt36=2;
            }
            else {
                ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:36 state:1 stream:input];
                @throw nvae;
            }
        }
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:36 state:0 stream:input];
            @throw nvae;
        }
        switch (alt36) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:254:9: {...}?lb= '[' ']' // alt
                {
                if ( !(([input LA:2] == RBRACK)) ) {
                    @throw [ANTLRFailedPredicateException exceptionWithRuleName:@"list" predicate:@"[input LA:2] == RBRACK" stream:input];
                }
                lb=(ANTLRCommonToken *)[self match:input TokenType:LBRACK Follow:FOLLOW_LBRACK_in_list2472];  
                    [stream_LBRACK addElement:lb];

                char_literal137=(ANTLRCommonToken *)[self match:input TokenType:RBRACK Follow:FOLLOW_RBRACK_in_list2474];  
                    [stream_RBRACK addElement:char_literal137];



                // AST REWRITE
                // elements: 
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 255:20: -> LIST[$lb]
                {
                    [treeAdaptor addChild:        [treeAdaptor createTree:LIST FromToken:lb Text:@"LIST"] toTree:root_0];

                }

                retval.tree = root_0;

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:256:9: lb= '[' listElement ( ',' listElement )* ']' // alt
                {
                lb=(ANTLRCommonToken *)[self match:input TokenType:LBRACK Follow:FOLLOW_LBRACK_in_list2491];  
                    [stream_LBRACK addElement:lb];

                /* ruleRef */
                [self pushFollow:FOLLOW_listElement_in_list2493];
                listElement138 = [self listElement];

                [self popFollow];


                [stream_listElement addElement:[listElement138 getTree]];
                do {
                    NSInteger alt35=2;
                    NSInteger LA35_0 = [input LA:1];
                    if ( (LA35_0==COMMA) ) {
                        alt35=1;
                    }


                    switch (alt35) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:256:30: ',' listElement // alt
                            {
                            char_literal139=(ANTLRCommonToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_list2497];  
                                [stream_COMMA addElement:char_literal139];

                            /* ruleRef */
                            [self pushFollow:FOLLOW_listElement_in_list2499];
                            listElement140 = [self listElement];

                            [self popFollow];


                            [stream_listElement addElement:[listElement140 getTree]];

                            }
                            break;

                        default :
                            goto loop35;
                    }
                } while (YES);
                loop35: ;

                char_literal141=(ANTLRCommonToken *)[self match:input TokenType:RBRACK Follow:FOLLOW_RBRACK_in_list2504];  
                    [stream_RBRACK addElement:char_literal141];



                // AST REWRITE
                // elements: listElement
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 256:53: -> ^( LIST[$lb] ( listElement )* )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:256:56: ^( LIST[$lb] ( listElement )* )
                    {
                        ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:        [treeAdaptor createTree:LIST FromToken:lb Text:@"LIST"]
                                                                               old:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:256:68: ( listElement )*
                        while ( [stream_listElement hasNext] ) {
                            [treeAdaptor addChild:[stream_listElement nextTree] toTree:root_1];

                        }
                        [stream_listElement reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];

        [stream_RBRACK release];
        [stream_LBRACK release];
        [stream_COMMA release];
        [stream_listElement release];

            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end list */

/*
 * $ANTLR start listElement
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:259:1: listElement : ( exprNoComma | -> A_NULL );
 */
- (STParser_listElement_return *) listElement
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    STParser_listElement_return * retval = [STParser_listElement_return newSTParser_listElement_return];
    [retval setStart:[input LT:1]];

    ANTLRCommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STParser_exprNoComma_return * exprNoComma142 = nil;



        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:259:13: ( exprNoComma | -> A_NULL ) //ruleblock
        NSInteger alt37=2;
        NSInteger LA37_0 = [input LA:1];

        if ( (LA37_0==SUPER||LA37_0==LPAREN||LA37_0==LBRACK||LA37_0==LCURLY||(LA37_0>=ID && LA37_0<=STRING)||LA37_0==AT) ) {
            alt37=1;
        }
        else if ( ((LA37_0>=RBRACK && LA37_0<=COMMA)) ) {
            alt37=2;
        }
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:37 state:0 stream:input];
            @throw nvae;
        }
        switch (alt37) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:259:15: exprNoComma // alt
                {
                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_exprNoComma_in_listElement2527];
                exprNoComma142 = [self exprNoComma];

                [self popFollow];


                [treeAdaptor addChild:[exprNoComma142 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:259:29:  // alt
                {

                // AST REWRITE
                // elements: 
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                ANTLRRewriteRuleSubtreeStream *stream_retval =
                    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 259:29: -> A_NULL
                {
                    [treeAdaptor addChild:        [treeAdaptor createTree:A_NULL Text:@"A_NULL"] toTree:root_0];

                }

                retval.tree = root_0;

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels
        [retval setStop:[input LT:-1]];


            retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (ANTLRRecognitionException *re) {
            @throw re;
        }
    @finally {
    }
    return retval;
}
/* $ANTLR end listElement */
/* ObjC end rules */

@end /* end of STParser implementation line 692 */
